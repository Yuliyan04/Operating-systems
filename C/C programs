~~~~~~~~~~~~~~ C/github_tasks/input_output/task5/main.c ~~~~~~~~~~~~~~

#include <unistd.h>
#include <err.h>
#include <fcntl.h>
#include <string.h>
#include <limits.h>
#include <stdint.h>
#include <stdio.h>

int main(int argc, char* argv[])
{
    if(argc != 3){
        err(1, "Program takes 3 arguments");
    }


    int minV = strcmp("--min", argv[1]);
    int printV = strcmp("--print", argv[1]);
    int maxV = strcmp("--max", argv[1]);

    if(minV != 0 && maxV != 0 && printV != 0){
        err(1, "Unmatched tag");
    }

    uint16_t min = UINT16_MAX;
    uint16_t max = 0;

    int fd = open(argv[2], O_RDONLY);
    if(fd < 0){
        err(1, "Error");
    }

    uint16_t num;
    int isRead;
    char buff[8];

    while((isRead = read(fd1, &num, sizeof(uint16_t))) > 0)
    {
        if(minV == 0)
        {
            if(num < min)
            {
                min = num;
            }
        }
        else if(maxV == 0)
        {
            if(num > max)
            {
                max = num;
            }
        }
        else
        {
            int len = snprintf(buf, sizeof(buf), "%u\n", num);
            if(write(1, buf, len) != len){
                err(1, "Error");
            }
        }
    }

    if(isRead < 0){
        err(1, "Error");
    }

    if(close(fd) < 0){
        err(1, "Error");
    }

    if(minV == 0)
    {
        int len = snprintf(buff, sizeof(buff), "%u\n", min);
        if(write(1, bufg, len) != len){
            err(1, "Error");
        }
    }
    else if(maxV == 0)
    {
        int len = snprintf(buff, sizeof(buff), "%u\n", max);
        if(write(1, buff, len) != len){
            err(1, "Error");
        }
    }

    return 0
}


~~~~~~~~~~~~~~ C/github_tasks/input_output/task4/main.c ~~~~~~~~~~~~~~

#include <unistd.h>
#include <err.h>
#include <fcntl.h>

int main(int argc, char* argv[])
{
    if(argc < 3){
        err(1, "Program needs mroe args");
    }

    int fd1 = open(argv[1], O_RDONLY);
    if(fd1 < 0){
        err(1, "Error");
    }

    int fd2 = open(argv[2], O_WRONLY);
    if(fd2 <0){
        err(1, "Error");
    }

    char buf[4096];
    int dataRead;

    while((dataRead = read(fd1, buf, 1024)) > 0)
    {
        for(int i = 0; i < dataRead; i++)
        {
            if(buf[i] == ':')
            {
                buf[i] = '?';
            }
        }

        int dataWritten = write(fd2, buf, dataRead);
        if(dataWritten < 0){
            err(1, "Error");
        }
    }

    if(dataRead < 0){
        err(1, "Error");
    }

    if(close(fd1) < 0 || close(fd2) < 0){
        err(1, "Error");
    }

    return 0;
}


~~~~~~~~~~~~~~ C/github_tasks/input_output/task8/main.c ~~~~~~~~~~~~~~

 #include <fcntl.h>
 #include <err.h>
 #include <unistd.h>

int main(int argc, const char* argv[])
{
    if(argc > 3){
        err(1, "Message");
    }

    int fd = open(argv[1], O_RDONLY);
    if(fd < 0){
        err(1, "Message");
    }

    if(argv[2] == "-c") {
        off_t = lseek(fd, 0, SEEK_END);
        char res[16];
        snprintf(res, 16, "%d\n", off_t);
        if(write(1, res, strlen(res))){
            err(1, "Error");
        }
    } else if(argv[2] == "-l") {
        int count = 0;
        char c;
        int flag;

        while(flag = read(fd, &c, 1) > 0)
        {
            if(c == '\n'){
                count++;
            }
        }

        if(flag < 0){
            err(1, "Error");
        }

        char res[16];
        snprintf(res, 16, "%d\n", count);
        if(write(1, res, strlen(res)) < 0){
            err(1, "Error");
        }
    } else if(argv[2] == "-w")

        int count = 1;
        char c;
        int flag;

        while(flag = read(fd, &c, 1) > 0)
        {
            if(c == ' '){
                count++;
            }
        }

        if(flag < 0){
            err(1, "Error");
        }

        char res[16];
        snprintf(res, 16, "%d\n", count);
        if(write(1, res, strlen(res)) < 0){
            err(1, "Error");
        }

    return 0;
}


~~~~~~~~~~~~~~ C/github_tasks/input_output/task2/main.c ~~~~~~~~~~~~~~

#include <unistd.h>
#include <err.h>
#include <fcntl.h>

void printFile(const char* filename)
{
    int fd = open(filename, O_RDONLY);
    if(fd < 0){
        err(1, "Can't open file %s", filename);
    }

    char buf[1024];
    int readData;

    while((readData = read(fd, buf, 1024)) > 0 )
    {
        writtenData = write(1, buf, readData);
        if(writtenData < 0){
            err(1, "Couldn't print the data to standart output");
        }
    }

    if(readData < 0 || writtenData < 0){
        err(1, "Error while reading the file %s. Stopping the reading.", filename);
    }

    if(close(fd) < 0){
        err(1, "Couldn't close %s", filename);
    }
}


int main(int argc, char* argv[])
{
    if(argc < 2) {
        err(1, "At least 1 argument needed");
    }

    for(int i = 1; i < argsc; i++)
    {
        printFile(argv[i]);
    }

    return 0;
}


~~~~~~~~~~~~~~ C/github_tasks/input_output/task7/main.c ~~~~~~~~~~~~~~

 #include <fcntl.h>
 #include <err.h>
 #include <unistd.h>

int main(int argc, const char* argv[])
{
    if(argc != 2){
        err(1, "Function needs two arguments\n");
    }

    int count = 0;
    char c;
    int fd = open(argv[1], O_RDONLY);
    int flag;

    if(fd < 0){
        err(1, "Couldn't open file");
    }

    while((flag = read(fd, &c, 1)) > 0 && count < 10)
    {
        int flag2 = write(1, &c, 1);
        if(flag2 < 0){
            err(1, "Couldn't write");
        }

        if(c == '\n')
        {
            count++;
        }
    }

    if(flag < 0){
        err(1, "Couldn't read");
    }

    return 0;
}


~~~~~~~~~~~~~~ C/github_tasks/input_output/task1/main.c ~~~~~~~~~~~~~~

#include <unistd.h>
#include <err.h>
#include <fcntl.h>

int main(int argc, char* argv[])
{
    if(argc != 3)
    {
        err(1, "Not enough arguments.");
    }

    int fd1 = open(argv[1], O_RDONLY);
    if(fd1 < 0)
    {
        err(1, "File can't be open");
    }

    int fd2 = open(argv[2], O_WRONLY);
    if(fd2 < 0)
    {
        err(1, "File can't be open for writing");
    }

    int sumRead = 0;
    int sumWritten = 0;

    char buf[1024];
    int readData = read(fd1, buf, 1024);
    int writtenData = write(fd2, buf, readData);
    sumRead += readData;
    sumWritten += writtenData;

    while(readData > 0 && writtenData > 0)
    {
        readData = read(fd1, buf, 1024);
        writtenData = write(fd2, buf, readData);
        sumRead += readData;
        sumWritten += writtenData;
    }

    if(readData < 0)
    {
        err(1, "Couldn't read data at once");
    }

    if(writtenData < 0)
    {
        err(1, "Couldn't write all of the data at once");
    }

    if(sumRead != sumWritten)
    {
       err(1, "Couldn't copy all of the data");
    }

    if(close(fd1) < 0)
    {
        err("First file wasn't closed");
    }

    if(close(fd2) < 0)
    {
        err("Second file can't be closed");
    }

    return 0;
}


~~~~~~~~~~~~~~ C/github_tasks/input_output/task6/main.c ~~~~~~~~~~~~~~

#include <unistd.h>
#include <err.h>
#include <fcntl.h>
#include <string.h>
#include <limits.h>
#include <stdint.h>
#include <stdio.h>

int main(int argc, char* argv[])
{
    if(argc != 2){
        err(1, "Program takes 2 arguments");
    }

    uint8_t max = 0;

    int fd = open(argv[2], O_RDONLY);
    if(fd < 0){
        err(1, "Error");
    }

    uint8_t num;
    int isRead;

    while((isRead = read(fd1, &num, sizeof(uint8_t))) > 0)
    {
        if(num > max)
        {
            max = num;
        }
    }

    if(isRead < 0){
        err(1, "Error");
    }

    if(close(fd) < 0){
        err(1, "Error");
    }

    char buff[8];
    len = snprintf(buff, sizeof(buff), "%u\n", max);
    write(1, buff, strlen(buff))

    return 0
}


~~~~~~~~~~~~~~ C/Sbornik/Processes/2023-SE-02/main.c ~~~~~~~~~~~~~~

#include <fcntl.h>
#include <err.h>
#include <unistd.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdbool.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <time.h>
#include <sys/time.h>
#include <pwd.h>
#include <errno.h>

int main(int argc, char* argv[])
{
    if(argc != 2) { err(1, "Not enough argumenets"); }

    pid_t pids[argc - 1];

    int wire[2];
    if(pipe(wire) < 0) { err(2, "Couldn't pipe"); }

    for(int i = 1; i < argc; i++)
    {
        int currPid = fork();
        if(currPid < 0) { err(3, "Couldn't fork"); }

        pids[i - 1] = currPid;
        if(currPid == 0)
        {
            if(close(wire[0]) < 0) { err(4, "Close pipe[0]"); }
            if(dup2(wire[1], 1) < 0) { err(5, "Dup2"); }
            if(close(wire[1]) < 0) { err(6, "Close pipe[1]"); }

            execlp(argv[i], argv[i], (char*)NULL);
            err(7, "Couldn't exec %s\n", argv[i]);
        }
    }

    if(close(wire[1]) < 0) { err(8, "Close"); }

    int grep = fork();
    if(grep < 0) { err(9, "Fork grep"); }
    if(grep == 0)
    {
        if(dup2(wire[0], 0) < 0) { err(10, "Dup2 pipe[0]"); }
        if(close(wire[0]) < 0) { err(11, "Close"); }

        execlp("grep", "grep", "-Eq", "found it!", (char*)NULL);
    }

    if(close(wire[0]) < 0) { err(12, "Close"); }

    int status;
    waitpid(grep, &status, 0);
    if(WEXITSTATUS(status) == 0)
    {
        for(int i = 0; i < argc - 1; i++)
        {
            if(kill(pids[i], SIGTERM) < 0) { err(13, "Kill"); }
        }
    }


    for(int i = 0; i < argc - 1; i++) { wait(NULL); }

    if(WEXITSTATUS(status) != 0) { exit(1); }

    exit(0);
}


~~~~~~~~~~~~~~ C/Sbornik/Processes/2023-SE-01/main.c ~~~~~~~~~~~~~~

#include <fcntl.h>
#include <err.h>
#include <unistd.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdbool.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <time.h>
#include <sys/time.h>
#include <pwd.h>
#include <errno.h>

//find argv[1] -mindepth 1 ! -name *.hash -type f | touch & heshsum & echo

bool processFile(char file[])
{
    char newFile[1032];
    snprintf(newFile, sizeof(newFile), "%s.hash", file);

    int fdNewFile = open(newFile, O_WRONLY | O_CREAT | O_EXCL, 0644);
    if(fdNewFile < 0)
    {
        if(errno == EEXIST) { return false; }

        err(9, "Open and create new file");
    }

    int hash = fork();
    if(hash < 0) { err(10, "Fork hash"); }
    if(hash == 0)
    {
        if(dup2(fdNewFile, 1) < 0) { err(11, "Dup2"); }

        execlp("md5sum", "md5sum", file, (char*)NULL);
        err(12, "Couldn't exec md5sum on %s", file);
    }

    if(close(fdNewFile) < 0) { err(12, "Close new file fd"); }
    return true;
}


int main(int argc, char* argv[])
{
    if(argc != 2) { err(1, "Not enough argumenets"); }

    int wire[2];
    if(pipe(wire) < 0) { err(2, "Pipe"); }

    int find = fork();
    if(find < 0) { err(3, "Fork find"); }
    if(find == 0)
    {
        if(close(wire[0]) < 0) { err(4, "Close"); }
        if(dup2(wire[1], 1) < 0) { err(5, "Dup2"); }
        if(close(wire[1]) < 0) { err(6, "Close"); }

        execlp("find", "find", argv[1], "-mindepth", "1", "!", "-name", "*.hash", "-type", "f", (char*)NULL);
        err(7, "Execlp  find");
    }

    if(close(wire[1]) < 0) { err(8, "Close wore[1]"); }

    int readBytes;
    char  file[1024];
    char c;
    size_t ind = 0;

    int waitsCount = 1;

    while((readBytes = read(wire[0], &c, sizeof(c))) > 0)
    {
        if(c == '\n')
        {
            file[ind] = '\0';
            ind = 0;
            waitsCount += processFile(file);
            continue;
        }

        file[ind] = c;
        ind++;
    }

    if(readBytes < 0) { err(13, "Read"); }

    if(close(wire[0]) < 0) { err(14, "Close");}

    for(int i = 0; i < waitsCount; i++) { wait(NULL); }

    return 0;
}


~~~~~~~~~~~~~~ C/Sbornik/Processes/2024-SE-01/main.c ~~~~~~~~~~~~~~

#include <fcntl.h>
#include <err.h>
#include <unistd.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdbool.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <time.h>
#include <sys/time.h>
#include <pwd.h>
#include <errno.h>

const char rndmFile[] = "/dev/urandom";

void getProgramName(const char* inp, char program[])
{
    int len = strlen(inp);
    int lastSepIndx = 0, commInd = 0;

    for(int i = 0; i < len; i++)
    {
        if(inp[i] == '/' && i != len - 1) { lastSepIndx = i; }
    }

    for(int i = lastSepIndx + 1; i < len; i++)
    {
        program[commInd] = inp[i];
        commInd++;
    }
    program[commInd] = '\0';
}


int main(int argc, const char* argv[])
{
    if(argc != 4) { err(1, "Not enough argumenets"); }

    int N = atoi(argv[2]);
    if(!(N >= 0 && N < 256)) { err(2, "Wrong value for N, N >= 0 && N < 256"); }

    int exitCode = 0;

    char program[128];
    getProgramName(argv[1], program);

    int res = open(argv[3], O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if(res < 0) { err(3, "Couldn't open res file %s", argv[3]); }

    int wire[2];
    if(pipe(wire) < 0) { err(4, "Couldn't pipe"); }

    int rndm = open(rndmFile, O_RDONLY);
    if(rndm < 0) { err(5, "Couldn't open /dev/urandom"); }

    if(dup2(wire[1], 1) < 0) { err(6, "Dup2 stdoud"); }
    if(close(wire[1]) < 0) { err(7, "Close pipe[1]"); }

    for(int i = 0; i < N; i++)
    {
        uint16_t currRndm; //let's say that the read num is always in the true interval
        if(read(rndm, &currRndm, sizeof(currRndm)) < 0) { err(8, "Error reading num from /dev/urandom"); }

        char bytes[currRndm];
        if(read(rndm, bytes, sizeof(bytes)) < 0) { err(9, "Rad from /dev/urandom"); }
        if(write(1, bytes, sizeof(bytes)) < 0) { err(10, "Write to pipe"); }

        int pid = fork();
        if(pid < 0) { err(11, "Fork"); }
        if(pid == 0)
        {
            if(dup2(wire[0], 0) < 0) { err(12, "Dup2 pipe[0]"); }
            if(close(wire[0]) < 0) { err(13, "Close pipe[0]"); }

            execl(argv[1], program, (char*)NULL);
            err(14, "Couldn't exec the program");
        }

        int status;
        wait(&status);
        if(!WIFEXITED(status))
        {
            if(write(res, bytes, sizeof(bytes)) < 0) { err(15, "Couldn't write to result file"); }
            exitCode = 42;
            break;
        }
    }

    if(close(wire[0]) < 0) { err(16, "Close"); }

    if(close(res) < 0 || close(rndm) < 0) { err(17, "Close"); }

    exit(exitCode);
}


~~~~~~~~~~~~~~ C/Sbornik/Processes/2017-IN-02/main.c ~~~~~~~~~~~~~~

#include <fcntl.h>
#include <err.h>
#include <unistd.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdbool.h>
#include <sys/stat.h>
#include <sys/wait.h>

bool readArgs(char arg1[], char arg2[])
{
    size_t ind = 0, spacesCount = 0;

    for(int i = 0; i < 10; i++)
    {
        if(ind >= 5) { err(101, "Invalid argument, strlen > 4"); }

        char c;
        if(read(0, &c, sizeof(c)) < 0) { err(102, "Read"); }

        if(c == '\n' && i == 0) { return false; }

        if(c == ' '){
            spacesCount++;
            ind = 0;
            continue;
        } else if(c == '\n') { break; }

        if(spacesCount == 0){ arg1[ind] = c; }
        else if(spacesCount == 1) { arg2[ind] = c; }

        ind++;
    }

    return true;
}


int main(int argc, const char* argv[])
{
    if(argc > 2) { err(1, "Arguments count"); }
    if(argc == 2 && strlen(argv[1]) > 4) { err(2, "Invalid parameter, strlen > 4"); }

    char command[5] = "";
    if(argc == 2) {
        strcpy(command, argv[1]);
    } else {
        strcpy(command, "echo");
    }

    char arg1[5] = "";
    char arg2[5] = "";
    while(readArgs(arg1, arg2))
    {
        int pid = fork();
        if(pid < 0) { err(3, "Fork"); }
        if(pid == 0)
        {
            if(strlen(arg2) == 0)
            {
                execlp(command, command, arg1, (char*)NULL);
                err(4, "Couldn't execlp the command");
            } else {
                execlp(command, command, arg1, arg2, (char*)NULL);
                err(5, "Couldn't execlp the command");
            }
        }

        strcpy(arg1, "");
        strcpy(arg2, "");

        int status;
        wait(&status);
        if(WEXITSTATUS(status) != 0) { err(6, "The program couldn't execute the command. Error"); }
    }

    return 0;
}


~~~~~~~~~~~~~~ C/Sbornik/Processes/2017-IN-01/main.c ~~~~~~~~~~~~~~

#include <fcntl.h>
#include <err.h>
#include <unistd.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdbool.h>
#include <sys/stat.h>
#include <sys/wait.h>

//  cut -d ':' -f 7 /etc/passwd | sort | uniq -c

int main(void)
{
    int pipe1[2];
    if(pipe(pipe1) < 0) { err(1, "Pipe"); }

    int pipe2[2];
    if(pipe(pipe2) < 0) { err(2, "Pipe"); }

    int cut = fork();
    if(cut < 0) { err(3, "Fork"); }
    if(cut == 0)
    {
        if(close(pipe1[0]) < 0 || close(pipe2[0]) < 0 || close(pipe2[1]) < 0) { err(3, "Close"); }

        if(dup2(pipe1[1], 1) < 0) { err(4, "Dup2"); }
        if(close(pipe1[1]) < 0) { err(5, "Close"); }

        execlp("cut", "cut", "-d:", "-f7", "/etc/passwd", (char*)NULL);
        err(6, "Execlp");
    }

    close(pipe1[1]);

    int sort = fork();
    if(sort < 0) { err(8, "Fork"); }
    if(sort == 0)
    {
        if(close(pipe1[1]) < 0 || close(pipe2[0]) < 0) { err(9, "Close"); }

        if(dup2(pipe1[0], 0) < 0) { err(10, "Dup2"); }
        if(close(pipe1[0]) < 0) { err(11, "Close"); }

        if(dup2(pipe2[1], 1) < 0) { err(12, "Dup2"); }
        if(close(pipe2[1]) < 0) { err(13, "Close"); }

        execlp("sort", "sort", (char*)NULL);
        err(14, "Execlp");
    }

    close(pipe1[0]);
    close(pipe2[1]);

    int uniq = fork();
    if(uniq < 0) { err(15, "Fork"); }
    if(uniq == 0)
    {
        if(close(pipe1[0]) < 0 || close(pipe1[1]) < 0 || close(pipe2[1]) < 0) { err(16, "Close"); }

        if(dup2(pipe2[0], 0) < 0) { err(17, "Dup2"); }
        if(close(pipe2[0]) < 0) { err(18, "Dup2"); }

        execlp("uniq", "uniq", "-c", (char*)NULL);
        err(19, "Execlp");
    }

    close(pipe2[0]);

    if(close(pipe1[0]) < 0 || close(pipe1[1]) < 0 || close(pipe2[0]) < 0 || close(pipe2[1]) < 0) { err(20, "Close"); }

    wait(NULL);
    wait(NULL);
    wait(NULL);

    return 0;
}


~~~~~~~~~~~~~~ C/Sbornik/Processes/2018-SE-01/main.c ~~~~~~~~~~~~~~

#include <fcntl.h>
#include <err.h>
#include <unistd.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdbool.h>
#include <sys/stat.h>
#include <sys/wait.h>

// find ./C/Sbornik/Processes/ -printf "%t\n" | sort | head -n 1

int main(int argc, const char* argv[])
{
    if(argc != 2) { err(1, "Arguments count"); }

    int findSort[2];
    int sortHead[2];

    if(pipe(findSort) < 0 || pipe(sortHead) < 0) { err(2, "Pipe"); }

    int find = fork();
    if(find < 0) { err(3, "Fork"); }
    if(find == 0)
    {
        if(close(findSort[0]) < 0 || close(sortHead[0]) < 0 || close(sortHead[1]) < 0) { err(4, "Close"); }

        if(dup2(findSort[1], 1) < 0) { err(5, "Dup2"); }
        if(close(findSort[1]) < 0) { err(6, "Close"); }

        execlp("find", "find", argv[1], "-printf", "%t\n", (char*)NULL);
        err(7, "Couldn't execlp find");
    }

    if(close(findSort[1]) < 0) { err(7, "Close"); }

    int sort = fork();
    if(sort < 0) { err(8, "Fork"); }
    if(sort == 0)
    {
        if(close(findSort[1]) < 0 || close(sortHead[0]) < 0) { err(9, "Close"); }

        if(dup2(findSort[0], 0) < 0) { err(10, "Dup2"); }
        if(close(findSort[0]) < 0) { err(11, "Close"); }

        if(dup2(sortHead[1], 1) < 0) { err(12, "Dup2"); }
        if(close(sortHead[1]) < 0) { err(13, "Close"); }

        execlp("sort", "sort", (char*)NULL);
        err(14, "Couldn't execlp sort");
    }

    if(close(findSort[0]) < 0 || close(sortHead[1]) < 0) { err(15, "Close"); }

    int head = fork();
    if(head < 0) { err(16, "Fork"); }
    if(head == 0)
    {
        if(close(findSort[0]) < 0 || close(findSort[1]) < 0 || close(sortHead[1]) < 0) { err(17, "Close"); }

        if(dup2(sortHead[0], 0) < 0) { err(18, "Dup2"); }
        if(close(sortHead[0]) < 0) { err(19, "Close"); }

        execlp("head", "head", "-n1", (char*)NULL);
        err(20, "Couldn't execlp head");
    }

    if(close(sortHead[0]) < 0) { err(21, "Close"); }

    wait(NULL);
    wait(NULL);
    wait(NULL);

    return 0;
}


~~~~~~~~~~~~~~ C/Sbornik/Processes/2021-SE-01/main.c ~~~~~~~~~~~~~~

#include <fcntl.h>
#include <err.h>
#include <unistd.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdbool.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <time.h>
#include <sys/time.h>
#include <pwd.h>

//ps -eo pid -U uid | xargs kill

const char filename[] = "foo.log";

int main(int argc, char* argv[])
{
    if(argc <= 1) { err(1, "Not enough argumenets"); }

    int log = open(filename, O_WRONLY | O_CREAT | O_APPEND, 0644);
    if(log < 0) { err(2, "Open"); }

    uid_t uid = getuid();
    char uidStr[8];
    snprintf(uidStr, sizeof(uidStr), "%u", uid);

    struct timeval tv;
    if(gettimeofday(&tv, NULL) < 0 ) { err(3, "gettimeofday"); }

    const struct tm* time = localtime(&tv.tv_sec);
    if(time == NULL) { err(4, "Localtime"); }

    char date[32];
    strftime(date, sizeof(date), "%F %T", time);
    char fullDate[64];
    snprintf(fullDate, sizeof(fullDate), "%s.%06ld", date, tv.tv_usec);

    struct passwd* usr_info = getpwuid(uid);
    if(usr_info == NULL) { err(5, "Getpwuid"); }
    char in = ' ';

    if(write(log, fullDate, strlen(fullDate)) < 0 || write(log, &in, sizeof(in)) < 0 ||
       write(log, usr_info->pw_name, strlen(usr_info->pw_name)) < 0 || write(log, &in, sizeof(in)) < 0) { err(6, "Write"); }

    for(int i = 1; i < argc; i++)
    {
        if(write(log, argv[i], strlen(argv[i])) < 0 || write(log, &in, sizeof(in)) < 0) { err(7, "Write"); }
    }

    char el = '\n';
    if(write(log, &el, sizeof(el)) < 0) { err(8, "Write"); }

    int pwd = fork();
    if(pwd < 0) { err(9, "Fork"); }
    if(pwd == 0)
    {
        execlp("passwd", "passwd", "-l", usr_info->pw_name, (char*)NULL);
        err(10, "Execlp");
    }

    wait(NULL);

    int pids[2];
    if(pipe(pids) < 0) { err(11, "Pipe"); }
    int ps = fork();
    if(ps < 0) { err(12, "Ps"); }
    if(ps == 0)
    {
        if(close(pids[0]) < 0) { err(13, "Close"); }

        if(dup2(pids[1], 1) < 0) { err(14, "Dup2"); }
        if(close(pids[1]) < 0) { err(15, "Dup2"); }

        execlp("ps", "ps", "-eo", "pid", "--no-headers", "-U", uidStr, (char*)NULL);
        err(13, "Execlp");
    }

    if(close(pids[1]) < 0) { err(16, "Close"); }

    int kill = fork();
    if(kill < 0) { err(17, "Fork"); }
    if(kill == 0)
    {
        if(dup2(pids[0], 0) < 0) { err(18, "Dup2"); }
        if(close(pids[0]) < 0) { err(19, "Close"); }

        execlp("xargs", "xargs", "kill", (char*)NULL);
        err(20, "Execlp xargs and kill");
    }

    if(close(pids[0]) < 0) { err(21, "Close"); }

    wait(NULL);
    wait(NULL);

    return 0;
}


~~~~~~~~~~~~~~ C/Sbornik/Processes/2020-SE-02/main.c ~~~~~~~~~~~~~~

#include <fcntl.h>
#include <err.h>
#include <unistd.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdbool.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <time.h>

int main(int argc, char* argv[])
{
    if(argc != 3) { err(1, "Not enough argumenets"); }

    int data[2];
    if(pipe(data) < 0) { err(2, "Couldn't pipe"); }

    int pid = fork();
    if(pid < 0) { err(3, "Fork"); }
    if(pid == 0)
    {
        if(close(data[0]) < 0) { err(4, "Close"); }
        if(dup2(data[1], 1) < 0) { err(5, "Dup2"); }
        if(close(data[1]) < 0) { err(6, "Close"); }

        execlp("cat", "cat", argv[1], (char*)NULL);
        err(7, "Couldn't exec cat on %s", argv[1]);
    }

    int outp = open(argv[2], O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if(outp < 0) { err(8, "Open"); }

    int readBytes;
    uint8_t byte;
    uint8_t mask = 0x20;
    uint8_t prev = 0;

    while((readBytes = read(data[0], &byte, sizeof(byte))) > 0)
    {
        if(prev == 0x7D)
        {
            byte = byte ^ mask;
        }
        else
        {
            if(byte == 0x55)
            {
                continue;
            }
            else if(byte == 0x7D)
            {
                prev = byte;
                continue;
            }
        }

        if(write(outp, &byte, sizeof(byte)) < 0) { err(9, "Write"); }
        prev = byte;
    }

    if(close(outp) < 0) { err(10, "Close"); }

    return 0;
}


~~~~~~~~~~~~~~ C/Sbornik/Processes/2024-SE-02/main.c ~~~~~~~~~~~~~~

#include <fcntl.h>
#include <err.h>
#include <unistd.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdbool.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <time.h>
#include <sys/time.h>
#include <pwd.h>
#include <errno.h>

void makeProcess(pid_t pids[], int pidInd)
{
    int pid = fork();
    if(pid < 0) { err(2, "Fork"); }

    pids[pidInd] = pid;
}

int main(int argc, const char* argv[])
{
    if(!(argc - 1 >= 1 && argc - 1 <= 10)) { err(1, "The program needs at least 1 argument"); }

    int exitCode = 0;

    pid_t pids[10];
    bool isExeced[10] = {false};
    int programs = argc - 1;
    int executed = 0;
    bool isKilled = false;
    int stillWait = 0;

    for(int i = 1; i < argc; i++)
    {
        int pidInd = i - 1;
        makeProcess(pids, pidInd);
        stillWait++;
        if(pids[pidInd] == 0)
        {
            execlp(argv[i], argv[i], (char*)NULL);
            err(3, "Couldn't exec %s\n", argv[i]);
        }
    }

    while(executed < programs)
    {
        for(int i = 0; i < programs; i++)
        {
            if(isExeced[i]) { continue; }

            int status;
            int res = waitpid(pids[i], &status, WNOHANG);
            if(res < 0) { err(4, "Waitpid"); }

            if(res == pids[i])
            {
                stillWait--;
                if(!WIFEXITED(status))
                {
                    isKilled = true;
                    exitCode = i + 1;
                    for(int j = 0; j < programs; j++)
                    {
                        if(isExeced[j]) { continue; }
                        if(kill(pids[j], SIGTERM) < 0) { err(5, "Couldn't kill process for commands %s\n", argv[j + 1]); }
                    }
                    break;
                }

                if(WEXITSTATUS(status) == 0)
                {
                    executed++;
                    isExeced[i] = true;
                }
                else
                {
                    makeProcess(pids, i);
                    stillWait++;
                    if(pids[i] == 0)
                    {
                        execlp(argv[i + 1], argv[i + 1], (char*)NULL);
                        err(6, "Couldn't exec %s", argv[i + 1]);
                    }
                }
            }
        }

        if(isKilled) { break; }
    }

    for(int i = 0; i < stillWait; i++) { wait(NULL); }

    exit(exitCode);
}


~~~~~~~~~~~~~~ C/Sbornik/Processes/2022-IN-01/main.c ~~~~~~~~~~~~~~

#include <fcntl.h>
#include <err.h>
#include <unistd.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdbool.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <time.h>
#include <sys/time.h>
#include <pwd.h>


const char DING[] = "DING ";
const char DONG[] = "DONG ";
char c = 'a';

int main(int argc, char* argv[])
{
    if(argc != 3) { err(1, "Not enough argumenets"); }

    if(strlen(argv[1]) != 1 || strlen(argv[2]) != 1) { err(2, "Wrong numbers format"); }

    int N = *argv[1] - '0';
    int D = *argv[2] - '0';

    int pipe1[2];
    if(pipe(pipe1) < 0) { err(13, "Pipe"); }

    int pipe2[2];
    if(pipe(pipe2) < 0) { err(14, "Pipe"); }

    int child = fork();
    if(child < 0) { err(4, "Error forking child"); }

    if(child == 0) { if(close(pipe1[1]) < 0 || close(pipe2[0]) < 0) { err(5, "Close"); } }
    else { if(close(pipe1[0]) < 0 || close(pipe2[1]) < 0) { err(9, "Close"); } }

    for(int i = 0; i < N; i++)
    {
       if(child != 0)
        {

            if(write(1, DING, strlen(DING)) < 0) { err(11, "Write"); }
            if(write(pipe1[1], &c, sizeof(c)) < 0) { err(12, "Write"); }

            if(read(pipe2[0], &c, sizeof(c)) < 0) { err(10, "Read"); }

            sleep(D);
        }
        else
        {
            if(read(pipe1[0], &c, sizeof(c)) < 0) { err(6, "Read"); }

            if(write(1, DONG, strlen(DONG)) < 0) { err(7, "Write"); }
            if(write(pipe2[1], &c, sizeof(c)) < 0) { err(8, "Write"); }

            if(i == N - 1) { exit(0); }
        }
    }

    wait(NULL);
    return 0;
}


~~~~~~~~~~~~~~ C/Sbornik/Processes/2020-SE-03/main.c ~~~~~~~~~~~~~~

#include <fcntl.h>
#include <err.h>
#include <unistd.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdbool.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <time.h>

int main(int argc, char* argv[])
{
    if(argc != 2) { err(1, "Not enough argumenets"); }

    int fd = open(argv[1], O_RDONLY);
    if(fd < 0) { err(2, "Open"); }

    int wire[2];
    if(pipe(wire) < 0) { err(3, "Pipe"); }

    struct stat f_info;
    if(fstat(fd, &f_info) < 0) { err(4, "Fstat"); }
    int count = f_info.st_size / 16;

    uint16_t finalRes = 0;

    for(int i = 0; i < count; i++)
    {
        char filename[8];
        uint32_t offset, len;

        if(read(fd, filename, sizeof(filename)) < 0 || read(fd, &offset, sizeof(offset)) < 0 || read(fd, &len, sizeof(len)) < 0) { err(5, "Read"); }

        int pid = fork();
        if(pid < 0) { err(6, "Fork"); }
        if(pid == 0)
        {
            int currFd = open(filename, O_RDONLY);
            if(currFd < 0) { err(7, "Open"); }

            if(lseek(currFd, offset * sizeof(uint16_t), SEEK_SET) < 0) { err(8, "Lseek"); }
            uint16_t res = 0;

            //let's say that the format is guaranteed so I don't need to check if the current file size is less than the offset + len * 2
            for(int j = 0; j < (int)len; j++)
            {
                uint16_t byte;
                if(read(currFd, &byte, sizeof(byte)) < 0) { err(9, "Read"); }
                res ^= byte;
            }

            if(close(wire[0]) < 0) { err(10, "Close"); }
            if(write(wire[1], &res, sizeof(res)) < 0) { err(11, "Write"); }
            if(close(wire[1]) < 0) { err(12, "Close"); }
            exit(0);
        }
    }

    if(close(wire[1]) < 0) { err(13, "Close"); }

    for(int i = 0; i < count; i++){
        wait(NULL);
    }

    int readBytes = 0;
    uint16_t currRes;
    while((readBytes = read(wire[0], &currRes, sizeof(currRes))) > 0)
    {
        finalRes ^= currRes;
    }

    if(readBytes < 0) { err(14, "Read"); }

    char buff[64];
    snprintf(buff, sizeof(buff), "result: %04X\n", finalRes);
    if(write(1, buff, strlen(buff)) < 0) { err(15, "Write"); }

    return 0;
}


~~~~~~~~~~~~~~ C/Sbornik/Processes/2016-SE-02/main.c ~~~~~~~~~~~~~~

#include <fcntl.h>
#include <err.h>
#include <unistd.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdbool.h>
#include <sys/stat.h>
#include <sys/wait.h>

int main(void)
{
    char prompt[] = "Enter command > ";
    char command[1024];
    char bin_path[1032];

    while(true)
    {
        if(write(1, prompt, strlen(prompt)) < 0) { err(1, "Write"); }

        int bytesRead = read(0, command, sizeof(command));
        if(bytesRead < 0) { err(2, "Read"); }
        command[bytesRead - 1] = '\0';

        if(strcmp(command, "exit") == 0) { break; }

        snprintf(bin_path, sizeof(bin_path), "/bin/%s", command);

        int pid = fork();
        if(pid < 0) { err(3, "Fork"); }

        if(pid == 0)
        {
            execl(bin_path, command, NULL);
            err(4, "Exec");
        }

        int stat;
        wait(&stat);
        if(!WIFEXITED(stat)) { err(5, "Command wasn't executed. "); }
    }

    return 0;
}


~~~~~~~~~~~~~~ C/Sbornik/Processes/2016-SE-01/main.c ~~~~~~~~~~~~~~

#include <fcntl.h>
#include <err.h>
#include <unistd.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdbool.h>
#include <sys/stat.h>

int main(int argc, const char* argv[])
{
    if(argc != 2){
        err(1, "Program needs 1 file");
    }

    int pfd[2];
    if(pipe(pfd) < 0) { err(2, "Pipe"); }

    int pid = fork();
    if(pid < 0) { err(6, "Fork"); }

    if(pid == 0)
    {
        if(close(pfd[0]) < 0) { err(10, "Close"); }
        if(dup2(pfd[1], 1) < 0) { err(11, "Dup2"); }
        if(close(pfd[1]) < 0) { err(12, "Close"); }

        execlp("cat", "cat", argv[1], NULL);
        err(3, "Execlp");
    }

    int pid2 = fork();
    if(pid2 < 0) { err(7, "Error"); }

    if(pid2 == 0)
    {
        if(close(pfd[1]) < 0) { err(13, "Close"); }
        if(dup2(pfd[0], 0) < 0) { err(14, "Dup2"); }
        if(close(pfd[0]) < 0) { err(15, "Close"); }

        execlp("sort", "sort", NULL);
        err(16, "Sort");
    }

    if(close(pfd[0]) < 0 || close(pfd[1]) < 0) { err(17, "Close"); }

    wait(NULL);
    wait(NULL);

    exit(0);
}


~~~~~~~~~~~~~~ C/Sbornik/Processes/2019-SE-01/main.c ~~~~~~~~~~~~~~

#include <fcntl.h>
#include <err.h>
#include <unistd.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdbool.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <time.h>

const char* filenamr = "run.log";

int main(int argc, char* argv[])
{
    if(argc < 2) { err(1, "Too few arguments"); }

    int max = *argv[1] - '0';
    if(!(max >= 1 && max <= 9)) { err(2, "Wrong max"); }

    char* commArgs[1024];
    for(int i = 2; i <= argc; i++)
    {
        if(i == argc){
            commArgs[i] = NULL;
            break;
        }
        commArgs[i - 2] = argv[i];
    }

    int prevCode = -1,  prevDiff = max;

    int runlog = open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if(runlog < 0) { err(101, "Open"); }

    while(true)
    {
        int currDiff;
        long long currStart = (long long)time(NULL);

        int pid = fork();
        if(pid < 0) { err(3, "Fork"); }
        if(pid == 0)
        {
            execvp(argv[2], commArgs);
            err(4, "Couldn't execvp the command");
        }

        long long currEnd = (long long)time(NULL);
        currDiff = (int)(currEnd - currStart);

        int status;
        wait(&status);

        if(WIFEXITED(status) == 0) { err(129, "Program was terminated"); }
        int currCode = WEXITSTATUS(status);

        if(write(runlog, &currStart, sizeof(currStart)) < 0 || write(runlog, &currEnd, sizeof(currEnd)) < 0 || write(runlog, &currCode, sizeof(currCode)) < 0) { err(102, "Write"); }
        if(prevCode != 0 && prevDiff < max && currCode != 0 && currDiff < max) { break; }

        prevCode = currCode;
        prevDiff = currDiff;
    }

    return 0;
}


~~~~~~~~~~~~~~ C/Sbornik/Input_output/2023-SE-02/main.c ~~~~~~~~~~~~~~

#include <fcntl.h>
#include <err.h>
#include <unistd.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdbool.h>
#include <sys/stat.h>

void readWord(int dict, char* buff, uint32_t buffSize)
{
    char c;
    int readBytes;
    uint8_t buffInd = 0;
    while((readBytes = read(dict, &c, sizeof(c))) > 0 && buffInd < buffSize - 1)
    {
        if(c == '\n')
        {
            break;
        }
        buff[buffInd] = c;
        buffInd++;
    }

    buff[buffInd] = '\0';
    if(readBytes < 0) { err(101, "Read"); }
}

int32_t findWordIndex(int dict, int positions, const char* word, uint32_t wordsCount)
{
    int left = 0;
    int right = wordsCount - 1;
    uint32_t seeked = -1;

    while(left <= right)
    {
        int mid = left + (right - left) / 2;
        if(lseek(positions, mid * sizeof(uint32_t), SEEK_SET) < 0) { err(4, "Lsrek"); }

        uint32_t currPos;
        if(read(positions, &currPos, sizeof(currPos)) < 0) { err(5, "Read"); }

        if(lseek(dict, currPos + 1, SEEK_SET) < 0) { err(6, "Lseek"); }
        char currWord[64];
        readWord(dict, currWord, 64);

        int res = strcmp(word, currWord);
        if(res == 0)
        {
            seeked = currPos;
            break;
        }
        else if(res < 0)
        {
            right = mid - 1;
        }
        else
        {
            left = mid + 1;
        }
    }
    return seeked;
}

void processDefinition(int dict, int32_t zeroBytePos, const char* word)
{
    uint32_t wordLen = strlen(word);
    if(lseek(dict, zeroBytePos + wordLen + 2, SEEK_SET) < 0) { err(201, "Lseek"); } //zeroBytesPos + the word len + the '\n' symbol + 1 to go to the position of the definition start

    char byte;
    int readBytes;
    while((readBytes = read(dict, &byte, sizeof(byte))) > 0)
    {
        if(byte == 0x00) { break; }

        if(write(1, &byte, sizeof(byte)) < 0){ err(202, "Write"); }
    }

    char newLine = '\n';
    if(write(1, &newLine, sizeof(newLine)) < 0) { err(204, "Wrote"); }
    if(readBytes < 0) { err(203, "Read"); }
}


int main(int argc, const char* argv[])
{
    if(argc != 4){
        err(1, "Arguments count");
    }

    int dict = open(argv[2], O_RDONLY);
    if(dict < 0) { err(1, "Open"); }

    int positions = open(argv[3], O_RDONLY);
    if(positions < 0) { err(2, "Open"); }

    struct stat pos_info;
    if(fstat(positions, &pos_info) < 0) { err(3, "fstat"); }

    uint32_t wordsCount = pos_info.st_size / sizeof(uint32_t);
    int32_t wordIndex =  findWordIndex(dict, positions, argv[1], wordsCount);
    if(wordIndex < 0) { err(20, "Word canÃ½ br found"); }
    processDefinition(dict, wordIndex, argv[1]);

    exit(0);
}


~~~~~~~~~~~~~~ C/Sbornik/Input_output/2023-SE-01/main.c ~~~~~~~~~~~~~~

#include <fcntl.h>
#include <err.h>
#include <unistd.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdbool.h>

void computeMessage(int stream, int messages)
{
    uint8_t N;

    if(read(stream, &N, sizeof(N)) < 0) { err(101, "Read"); }

    if(N < 3) return;

    uint8_t checkSum = 0x55 ^ N;
    uint8_t checkSumFile;

    int bytesCount = N - 3;
    char* message = malloc(bytesCount + 1);
    message[bytesCount] = '\n';

    uint8_t byte;

    for(int i = 0; i < bytesCount; i++)
    {
        if(read(stream, &byte, sizeof(byte)) < 0) { err(102, "Read"); }
        checkSum ^= byte;
        message[i] = (char)byte;
    }

    if(read(stream, &checkSumFile, sizeof(checkSumFile)) < 0) { err(103, "Read"); }

    if(checkSum == checkSumFile)
    {
        if(write(messages, message, bytesCount + 1) < 0) { err(104, "Read"); }
    }

    free(message);
}


int main(int argc, const char* argv[])
{
    if(argc != 3){
        err(1, "Arguments count");
    }

    int stream = open(argv[1], O_RDONLY);
    if(stream < 0) { err(1, "Open"); }

    int messages = open(argv[2], O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if(messages < 0) { err(2, "Open"); }

    uint8_t byte;
    int bytesRead;

    while((bytesRead = read(stream, &byte, sizeof(byte))) > 0)
    {
        if(byte == 0x55)
        {
            computeMessage(stream, messages);
        }
    }

    exit(0);
}


~~~~~~~~~~~~~~ C/Sbornik/Input_output/2021-SE-02/main.c ~~~~~~~~~~~~~~

#include <fcntl.h>
#include <err.h>
#include <unistd.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdbool.h>

int main(int argc, const char* argv[])
{
    if(argc != 3){
        err(1, "Incorrect input");
    }

    int inp = open(argv[1], O_RDONLY);
    if(inp < 0){
        err(1, "Open");
    }

    int outp = open(argv[2], O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if(outp < 0){
        err(2, "Open");
    }

    uint8_t byte1;
    uint8_t byte2;
    int readBytes;

    while((readBytes = read(inp, &byte1, sizeof(byte1))) > 0 && (readBytes = read(inp, &byte2, sizeof(byte2))) > 0)
    {
        uint8_t byte = 0;
        int outPos = 7;

        for(int i = 6; i >= 0; i -= 2)
        {
            int mask = (2 << i);
            if(mask & byte2)
            {
                byte |= (1 << outPos);
            }
            outPos--;
        }

        for(int i = 6; i >= 0; i-= 2)
        {
            int mask = (2 << i);
            if(mask & byte1)
            {
                byte |= (1 << outPos);
            }
            outPos--;
        }

        if(write(outp, &byte, sizeof(byte)) < 0){
            err(1, "Error");
        }
    }

    if(readBytes < 0){
        err(3, "Read");
    }

    if(close(inp) < 0 || close(outp) < 0){
        err(4, "Close");
    }
    exit(0);
}


~~~~~~~~~~~~~~ C/Sbornik/Input_output/2018-SE-03/main.c ~~~~~~~~~~~~~~

#include <fcntl.h>
#include <err.h>
#include <unistd.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdbool.h>

void processC(int beg, int end)
{
    char c;
    int readBytes;
    int count = 1;
    while((readBytes = read(0, &c, sizeof(c))) > 0)
    {
        if(count >= beg && count <= end)
        {
            if(write(1, &c, sizeof(c)) < 0){
                err(1, "Error");
            }

            if(count == end){
                char s = '\n';
                if(write(1, &s, sizeof(s)) < 0){
                    err(1, "Error");
                }
            }
            count++;
        }

        if(c == '\n')
        {
            count = 1;
        }
    }

    if(readBytes < 0){
        err(1, "Error");
    }
}

void processD(char sep, int beg, int end)
{
     char c;
     int bytesRead;
     int count = 1;

     while((bytesRead = read(0, &c, sizeof(c))) > 0)
     {
        if(count >= beg && count <= end)
        {
            if(!(c == sep && count == beg && count == end))
                if(write(1, &c, sizeof(c)) < 0){
                    err(1, "Error");
                }
        }

        if(c == sep){
            count++;
        }
        else if(c == '\n')
        {
            if(write(1, &c, sizeof(c)) < 0){
                err(1, "Error");
            }
            count = 1;
        }
     }
}


int main(int argc, const char* argv[])
{
    if(strcmp(argv[1], "-c") == 0)
    {
        if(strlen(argv[2]) == 1)
        {
            processC(argv[2][0] - '0', argv[2][0] - '0');
        }
        else
        {
            processC(argv[2][0] - '0', argv[2][2] - '0');
        }
    }
    else
    {
        if(strlen(argv[4]) == 1)
        {
            processD(argv[3][1], argv[4][0] - '0', argv[4][0] - '0');
        }
        else
        {
            processD(argv[3][1], argv[4][0] - '0', argv[4][2] - '0');
        }
    }
    exit(0);
}


~~~~~~~~~~~~~~ C/Sbornik/Input_output/2024-SE-01/main.c ~~~~~~~~~~~~~~

#include <fcntl.h>
#include <err.h>
#include <unistd.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdbool.h>
#include <sys/stat.h>

bool findInFile(int temp, uint64_t index)
{
    if(lseek(temp, 0, SEEK_SET) < 0) { err(102, "Lseek"); }

    uint64_t curr;
    int readBytes;
    while((readBytes = read(temp, &curr, sizeof(curr))) > 0)
    {
        if(curr == index) { return true; }
    }
    if(readBytes < 0) {err(101, "Read"); }

    return false;
}

int main(int argc, const char* argv[])
{
    if(argc != 2){
        err(1, "Wrong arguments count");
    }

    int fd = open(argv[1], O_RDWR);
    if(fd < 0) { err(2, "Open"); }

    char template[] = "/tmp/XXXXXX";
    int tempFile = mkstemp(template);
    if(tempFile < 0) { err(3, "Mkstemp"); }

    uint64_t next = 0;
    int readBytes = 0;

    if(write(tempFile, &next, sizeof(next)) < 0) { err(235, "Write"); }
    while((readBytes = read(fd, &next, sizeof(next))) > 0)
    {
        if(next == 0)
        {
            break;
        }

        if(write(tempFile, &next, sizeof(next)) < 0) { err(4, "Write"); }

        if(lseek(fd, next * 512, SEEK_SET) < 0) { err(5, "Lseek"); }
    }

    if(lseek(fd, 0, SEEK_SET) < 0) { err(325, "Lseek"); }

    struct stat fd_info;
    if(fstat(fd, &fd_info) < 0) { err(6, "Fstat"); }

    uint8_t zeroes[512];
    for(int i = 0; i < 512; i++){
        zeroes[i] = 0;
    }

    uint64_t nodesCount = fd_info.st_size / 512;
    for(uint64_t i = 0; i < nodesCount; i++)
    {
        if(!findInFile(tempFile, i))
        {
            if(lseek(fd, i * 512, SEEK_SET) < 0) { err(237, "LSeek"); }
            if(write(fd, zeroes, sizeof(zeroes)) != sizeof(zeroes)) { err(7, "Write"); }
        }
    }

    if(readBytes < 0) { err(8, "Read"); }

    if(close(fd) < 0 || close(tempFile) < 0) { err(9, "Close"); }
    unlink(template);

    exit(0);
}


~~~~~~~~~~~~~~ C/Sbornik/Input_output/2017-SE-04/main.c ~~~~~~~~~~~~~~

#include <fcntl.h>
#include <err.h>
#include <unistd.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdbool.h>

void readFromStream(int fd)
{
    char buff[4096];
    int bytesRead;
    while((bytesRead = read(fd, buff, sizeof(buff))) > 0)
    {
        if(bytesRead == 1 && buff[0] == '\n')
        {
            break;
        }

        if(write(1, buff, bytesRead) < 0){
            err(1, "Error");
        }
    }

    if(bytesRead < 0){
        err(1, "Error while reading from...");
    }
}

int main(int argc, const char* argv[])
{
    if(argc == 1)
    {
        readFromStream(0);
        exit(0);
    }

    for(int i = 1; i < argc; i++)
    {
        if(strcmp(argv[i], "-") == 0)
        {
            readFromStream(0);
        }
        else
        {
            int fd = open(argv[i], O_RDONLY);
            if(fd < 0){
                err(1, "Error while opening %s", argv[i]);
            }

            readFromStream(fd);
            if(close(fd) < 0){
                err(1, "Error while closing %s", argv[i]);
            }
        }
    }

    exit(0);
}


~~~~~~~~~~~~~~ C/Sbornik/Input_output/2017-IN-01/main.c ~~~~~~~~~~~~~~

#include <fcntl.h>
#include <err.h>
#include <unistd.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdbool.h>

int main(int argc, const char* argv[])
{
    if(argc != 5){
        err(1, "File needs 4 files");
    }


    int dat1 = open(argv[1], O_RDONLY);
    if(dat1 < 0){
        err(1, "Error");
    }
    int idx1 = open(argv[2], O_RDONLY);
    if(idx1 < 0){
        err(1, "Error");
    }
    int dat2 = open(argv[3], O_WRONLY | O_TRUNC | O_CREAT, 0644);
    if(dat2 < 0){
        err(1, "Error");
    }
    int idx2 = open(argv[4], O_WRONLY | O_TRUNC | O_CREAT, 0644);
    if(idx2 < 0){
        err(1, "Error");
    }

    off_t dat1Size = lseek(dat1, 0, SEEK_END);
    off_t idx1Size = lseek(idx1, 0, SEEK_END);
    if(dat1Size <= 0 || idx1Size <= 0){
        err(1, "Error");
    }

    if(lseek(idx1, 0, SEEK_SET) < 0){
        err(1, "Error");
    }

    uint16_t beg;
    uint8_t len;
    uint8_t something;
    uint16_t currPos = 0;
    int isOk;

    while((isOk = read(idx1, &beg, sizeof(beg))) > 0 && (isOk = read(idx1, &len, sizeof(len))) > 0 && (isOk = read(idx1, &something, sizeof(something))) >0)
    {
        bool isUpper = 1;
        if((off_t)(beg + len) > dat1Size){
            err(1, "Error");
        }

        if(lseek(dat1, (off_t)beg, SEEK_SET) < 0){
            err(1, "Error");
        }

        for(int i = 0; i < (int)len; i++)
        {
            char c;
            if(read(dat1, &c, sizeof(c)) < 0){
                err(1, "Error");
            }

            if(i == 0 && (c >= 'a' && c <= 'z'))
            {
                isUpper = 0;
                break;
             }

            if(write(dat2, &c, sizeof(c)) < 0){
                err(1, "Error");
            }
        }

        if(isUpper){
            if(write(idx2, &currPos, sizeof(currPos)) < 0){
                err(1, "Error");
            }
            if(write(idx2, &len, sizeof(len)) < 0){
                err(1, "Error");
            }
            if(write(idx2, &something, sizeof(something)) < 0){
                err(1, "Error");
            }
            currPos += len;
        }
    }
    if(close(dat1) < 0 || close(idx1) < 0 || close(dat2) < 0 || close(idx2) < 0){
        err(1, "Error");
    }

    exit(0);
}


~~~~~~~~~~~~~~ C/Sbornik/Input_output/2018-SE-01/main.c ~~~~~~~~~~~~~~

#include <fcntl.h>
#include <err.h>
#include <unistd.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdbool.h>

bool isInSet(const char set[], char c)
{
    int size = strlen(set);
    for(int i = 0; i < size; i++)
    {
        if(set[i] == c)
        {
            return 1;
        }
    }
    return 0;
}

void processD(const char set[])
{
    char c;
    int readBytes;
    while((readBytes = read(0, &c, sizeof(c))) > 0)
    {
        if(!isInSet(set, c))
        {
            if(write(1, &c, sizeof(c)) < 0){
                err(1, "Error");
            }
        }
    }

    if(readBytes < 0){
        err(1, "Error");
    }
}

void processS(const char set[])
{
    char prev;
    if(read(0, &prev, sizeof(prev)) < 0){
        err(1, "Error");
    }

    if(write(1, &prev, sizeof(prev)) < 0){
        err(1, "Error");
    }

    char c;
    int bytesRead;

    while((bytesRead = read(0,&c, sizeof(c))) > 0)
    {
        if(!(c == prev && isInSet(set, c)))
        {
            if(write(1, &c, sizeof(c)) < 0)
            {
                err(1, "Error");
            }
        }
        prev = c;
    }

    if(bytesRead < 0){
        err(1, "Error");
    }
}


int main(int argc, const char* argv[])
{
    if(argc != 3){
        err(1, "Second string is not needed...Too much arguments");
    }


    if(strcmp(argv[1], "-s") == 0)
    {
        processS(argv[2]);
    }
    else if(strcmp(argv[1], "-d") == 0)
    {
        processD(argv[2]);
    }
    else
    {
        int size1 = strlen(argv[1]);
        int size2 = strlen(argv[2]);
        if(size1 != size2){
            err(1, "Strings must have the same length");
        }

        char c;
        int readBytes = 0;

        while((readBytes = read(0, &c, sizeof(c))) > 0)
        {
            int pos = -1;
            for(int i = 0; i < size1; i++)
            {
                if(c == argv[1][i])
                {
                    pos = i;
                    break;
                }
            }

            char toWrite = c;
            if(pos != -1)
            {
                toWrite = argv[2][pos];
            }

            if(write(1, &toWrite, sizeof(toWrite)) < 0){
                err(1, "Error");
            }
        }

        if(readBytes < 0){
            err(1, "Error");
        }
    }

    exit(0);
}


~~~~~~~~~~~~~~ C/Sbornik/Input_output/2023-IN-01/main.c ~~~~~~~~~~~~~~

#include <fcntl.h>
#include <err.h>
#include <unistd.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdbool.h>

uint32_t computedBytes = 0;

void computeData(int inp, int outp, uint8_t key[], int keySize, uint32_t orgBytes)
{
    uint8_t data[16];
    if(read(inp, data, sizeof(data)) < 0){
        err(201, "Read");
    }

    for(int i = 0; i < keySize; i++)
    {
        data[i] ^= key[i];
    }

    for(int i = 0; i < keySize; i++)
    {
        if(computedBytes < orgBytes)
        {
            if(write(outp, &data[i], sizeof(data[i])) < 0){
                err(202, "Wrirte");
            }
        }
        computedBytes++;
    }
}

void computeSection(int inp, int outp, uint8_t sectionKey[], int sKeySize, uint32_t offset, uint32_t orgBytes)
{
    if(lseek(inp, offset * 16, SEEK_SET) < 0){
        err(101, "Lseek");
    }

    uint8_t lenANDOfft[16];
    if(read(inp, lenANDOfft, sizeof(lenANDOfft)) < 0){
        err(102,  "Read");
    }

    for(int i = 0; i < sKeySize; i++)
    {
        lenANDOfft[i] ^= sectionKey[i];
    }

    int64_t relOfft = 0;
    uint64_t len = 0;

    for(int i = 0; i < 8; i++)
    {
        relOfft |= ((int64_t)lenANDOfft[i] << (8 * i));
    }

    for(int i = 0; i < 8; i++)
    {
        len |= ((uint64_t)lenANDOfft[i + 8] << (8 * i));
    }

    uint8_t key[16];
    if(read(inp, key, sizeof(key)) < 0){
        err(103, "Read");
    }

    for(int i = 0; i < sKeySize; i++)
    {
        key[i] ^= sectionKey[i];
    }

    if(lseek(inp, (relOfft + offset) * 16, SEEK_SET) < 0){
        err(104, "Read");
    }

    for(uint32_t i = 0; i < len; i++)
    {
        computeData(inp, outp, key, 16, orgBytes);
    }
}


int main(int argc, const char* argv[])
{
    if(argc != 3){
        err(1, "Arguments count");
    }

    int encrypted = open(argv[1], O_RDONLY);
    if(encrypted < 0){
        err(2, "Open");
    }
    int decrypted = open(argv[2], O_WRONLY | O_TRUNC | O_CREAT, 0644);
    if(decrypted < 0){
        err(3, "Open");
    }


    uint64_t magic;
    if(read(encrypted, &magic, sizeof(magic)) < 0){
        err(4, "Read");
    }

    if(magic != 0x0000534f44614c47){
        err(5, "Invalid magic");
    }

    uint32_t bytesCount, unitsCount, orgBytesCount, orgUnitsCount, unused, checkSum;
    uint8_t sectionKey[16];
    uint32_t slots[4];

    if(read(encrypted, &bytesCount, sizeof(bytesCount)) < 0 || read(encrypted, &unitsCount, sizeof(unitsCount)) < 0 || read(encrypted, &orgBytesCount, sizeof(orgBytesCount)) < 0
        || read(encrypted, &orgUnitsCount, sizeof(orgUnitsCount)) < 0 || read(encrypted, &unused, sizeof(unused)) < 0 || read(encrypted, &checkSum, sizeof(checkSum)) < 0
        || read(encrypted, sectionKey, sizeof(sectionKey)) < 0 || read(encrypted, slots, sizeof(slots)) < 0)
    {
        err(6, "Read");
    }

    struct stat info_encrypted;
    if(fstat(encrypted, &info_encrypted) < 0){
        err(7, "Error");
    }

    if(info_encrypted.st_size != bytesCount){
        err(8, "Logical error");
    }

    for(int i = 0; i < 4; i++)
    {
        if(slots[i] != 0)
        {
            computeSection(encrypted, decrypted, sectionKey, 16, slots[i], orgBytesCount);
        }
    }

    struct stat info_decr;
    if(fstat(decrypted, &info_decr) < 0){
        err(9, "Fstat");
    }

    if(info_decr.st_size != orgBytesCount){
        err(10, "LOgical error");
    }

    if(close(encrypted) < 0 || close(decrypted) < 0){
        err(11, "Close");
    }

    exit(0);
}


~~~~~~~~~~~~~~ C/Sbornik/Input_output/2021-SE-01/main.c ~~~~~~~~~~~~~~

#include <fcntl.h>
#include <err.h>
#include <unistd.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdbool.h>

int main(int argc, const char* argv[])
{
    if(argc != 3){
        err(1, "Incorrect input");
    }

    int inp = open(argv[1], O_RDONLY);
    if(inp < 0){
        err(2, "Input");
    }

    int outp = open(argv[2], O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if(outp < 0){
        err(3, "Output");
    }

    uint8_t byte;
    int readBytes;
    while((readBytes = read(inp, &byte, sizeof(byte))) > 0)
    {
        uint8_t byte1 = 0;
        uint8_t byte2 = 0;

        for(int i = 7; i >= 4; i--)
        {
            int mask = (1 << i);

            if (mask & byte){
                byte1 |= 2;
            } else {
                byte1 |= 1;
            }

            if(i > 4){
                byte1 = byte1 << 2;
            }
        }

        for(int i = 3; i >= 0; i--)
        {
            int mask = (1 << i);

            if(mask & byte){
                byte2 |= 2;
            } else {
                byte2 |= 1;
            }

            if(i > 0){
                byte2 = byte2 << 2;
            }
        }

        if(write(outp, &byte1, sizeof(byte1)) < 0 || write(outp, &byte2, sizeof(byte2)) < 0){
            err(5, "Write");
        }
    }

    if(readBytes < 0){
        err(4, "Reading");
    }

    if(close(inp) < 0 || close(outp) < 0){
        err(6, "Close");
    }

    exit(0);
}


~~~~~~~~~~~~~~ C/Sbornik/Input_output/2020-SE-02/main.c ~~~~~~~~~~~~~~

#include <fcntl.h>
#include <err.h>
#include <unistd.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdbool.h>

int main(int argc, const char* argv[])
{
    if(argc != 3){
        err(1, "Error");
    }

    int scl = open(argv[1], O_RDONLY);
    if(scl < 0){
        err(1, "Open f1");
    }

    int sdl = open(argv[2], O_RDONLY);
    if(sdl < 0){
        err(1, "Error");
    }

    int newFile = open("sdl_new", O_CREAT | O_WRONLY | O_TRUNC, 0644);
    if(newFile < 0){
        err(1, "Error");
    }

    int pos = 0;
    uint16_t el;
    int readBytes;

    while((readBytes = read(sdl, &el, sizeof(el))) > 0)
    {
        int bucket = pos / 8;
        int bucketPos = pos % 8;

        if(lseek(scl, (off_t)bucket, SEEK_SET) < 0){
            err(1, "Error");
        }

        uint8_t curr;
        if(read(scl, &curr, sizeof(curr)) < 0){
            err(1, "Error");
        }

        uint8_t mask = 1;
        mask = mask << (7 - bucketPos);

        if(mask & curr)
        {
            if(write(newFile, &el, sizeof(el)) < 0){
                err(1, "Error");
            }
        }

        pos++;
    }

    if(readBytes < 0){
        err(1, "Error");
    }

    if(close(sdl) < 0 || close(newFile) < 0 || close(scl) < 0){
        err(1, "Error");
    }

    exit(0);
}


~~~~~~~~~~~~~~ C/Sbornik/Input_output/2024-SE-02/main.c ~~~~~~~~~~~~~~

#include <fcntl.h>
#include <err.h>
#include <unistd.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdbool.h>
#include <sys/stat.h>

void handlePack(int compr, int decompr, uint8_t kind, uint8_t N)
{
    uint8_t byte;

    if(kind == 0)
    {
        for(int i = 1; i <= N + 1; i++)
        {
            if(read(compr, &byte, sizeof(byte)) < 0) { err(102, "Read"); }
            if(write(decompr, &byte, sizeof(byte)) != sizeof(byte)) { err(103, "Write"); }
        }
    }
    else if(kind == 1)
    {
        if(read(compr, &byte, sizeof(byte)) < 0) { err(104, "Read"); }

        for(int i = 1; i <= N + 1; i++)
        {
            if(write(decompr, &byte, sizeof(byte)) != sizeof(byte)) { err(105, "Write"); }
        }
    }
    else
    {
        err(101, "Logical error");
    }
}


int main(int argc, const char* argv[])
{
    if(argc != 3){
        err(1, "Arguments count");
    }

    int compressed = open(argv[1], O_RDONLY);
    if(compressed < 0) { err(2, "Open"); }
    int decompressed = open(argv[2], O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if(decompressed < 0) { err(3, "Open"); }

    uint32_t magic;
    if(read(compressed, &magic, sizeof(magic)) < 0) { err(4, "Read"); }
    if(magic != 0x21494D46) { err(5, "Wrong magic"); }

    uint32_t packCount;
    uint64_t orgSize;

    if(read(compressed, &packCount, sizeof(packCount)) < 0 || read(compressed, &orgSize, sizeof(orgSize)) < 0) { err(6, "Read"); }

    for(uint32_t i = 0; i < packCount; i++)
    {
        uint8_t byte;
        if(read(compressed, &byte, sizeof(byte)) < 0) { err(7, "Read"); }

        uint8_t packKind = byte >> 7;
        uint8_t N = ((uint8_t)(~(1 << 7))) & byte;

        handlePack(compressed, decompressed, packKind, N);
    }

    exit(0);
}


~~~~~~~~~~~~~~ C/Sbornik/Input_output/2022-IN-01/main.c ~~~~~~~~~~~~~~

#include <fcntl.h>
#include <err.h>
#include <unistd.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdbool.h>

const uint32_t MAX_SIZE = 524288;

int main(int argc, const char* argv[])
{
    if(argc != 4){
        err(1, "Incorrect input");
    }

    int list = open(argv[1], O_RDONLY);
    if(list < 0){
        err(2, "Open");
    }
    int data = open(argv[2], O_RDONLY);
    if(data < 0){
        err(3, "Open");
    }
    int out = open(argv[3], O_RDWR);
    if(out < 0){
        err(4, "Error");
    }

    uint16_t magicList, magicData, magicOut;
    uint16_t ftypeList, ftypeData, ftypeOut;
    uint32_t countList, countData, countOut;

    if(read(list, &magicList, sizeof(magicList)) < 0 || read(list, &ftypeList, sizeof(ftypeList)) < 0 || read(list, &countList, sizeof(countList)) < 0){
        err(5, "Error");
    }

    if(read(data, &magicData, sizeof(magicData)) < 0 || read(data, &ftypeData, sizeof(ftypeData)) < 0 || read(data, &countData, sizeof(countData)) < 0){
        err(6, "Error");
    }

    if(read(out, &magicOut, sizeof(magicOut)) < 0 || read(out, &ftypeOut, sizeof(ftypeOut)) < 0 || read(out, &countOut, sizeof(countOut)) < 0){
        err(7, "Error");
    }

    if(magicList != 0x5A4D || ftypeList != 1){
        err(8, "Error");
    }

    if(magicData != 0x5A4D || ftypeData != 2){
        err(9, "Error");
    }

    if(magicOut != 0x5A4D || ftypeOut != 3){
        err(10 , "Error");
    }

    uint16_t pos, val;
    int readBytes;
    while((readBytes = read(list, &pos, sizeof(pos))) > 0 && (readBytes = read(list, &val, sizeof(val))) > 0)
    {
        if(lseek(data, (off_t)pos, SEEK_SET) < 0){
            err(12, "Lseek");
        }

        uint32_t currData;
        if(read(data, &currData, sizeof(currData)) < 0){
            err(13, "Read");
        }

        if(lseek(out, (off_t)val, SEEK_SET) < 0){
            err(14, "Lseek");
        }

        uint64_t currData64 = (uint64_t)currData;
        if(write(out, &currData64, sizeof(currData64)) < 0){
            err(15, "Error");
        }
    }

    if(readBytes < 0){
        err(11, "Error");
    }

    if(close(list) < 0 || close(data) < 0 || close(out) < 0){
        err(16, "Close");
    }

    exit(0);
}


~~~~~~~~~~~~~~ C/Sbornik/Input_output/2022-SE-01/main.c ~~~~~~~~~~~~~~

#include <fcntl.h>
#include <err.h>
#include <unistd.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdbool.h>

const uint32_t MAX_SIZE = 524288;

int main(int argc, const char* argv[])
{
    if(argc != 3){
        err(1, "Incorrect input");
    }

    int data = open(argv[1], O_RDONLY);
    if(data < 0){
        err(2, "Open");
    }

    int compare = open(argv[2], O_RDONLY);
    if(compare < 0){
        err(3, "Open");
    }

    uint32_t magic, countData;

    if(read(data, &magic, sizeof(magic)) < 0 || read(data, &countData, sizeof(countData)) < 0){
        err(4, "Read");
    }

    if(magic != 0x21796F4A){
        err(5, "Logical error");
    }

    uint32_t magic1;
    uint16_t magic2, reserved;
    uint64_t countComp;

    if(read(compare, &magic1, sizeof(magic1)) < 0 || read(compare, &magic2, sizeof(magic2)) < 0 || read(compare, &reserved, sizeof(reserved)) < 0 || read(compare, &countComp, sizeof(countComp)) < 0){
        err(6, "Read");
    }

    uint16_t type, reserved1, reserved2, reserved3;
    uint32_t offset1, offset2;

    for(uint64_t i = 0; i < countComp; i++)
    {
        if(read(compare, &type, sizeof(type)) < 0 || read(compare, &reserved1, sizeof(reserved1)) < 0 || read(compare, &reserved2, sizeof(reserved2)) ||
           read(compare, &reserved3, sizeof(reserved3)) < 0 || read(compare, &offset1, sizeof(offset1)) < 0 || read(compare, &offset2, sizeof(offset2)) < 0){
            err(7, "Read");
        }

        if(reserved1 != 0 || reserved2 != 0 || reserved2 != 0){
            err(12, "Reserved != 0");
        }

        uint64_t num1, num2;
        if(lseek(data, (off_t)offset1, SEEK_SET) < 0){
            err(8, "Lseek");
        }

        if(read(data, &num1, sizeof(num1)) < 0){
            err(9, "Read");
        }

        if(lseek(data, (off_t)offset2, SEEK_SET) < 0){
            err(10, "Lseek");
        }

        if(read(data, &num2, sizeof(num2)) < 0){
            err(11, "Read");
        }

        bool fulfilled = 1;
        if(type == 1){
            if(!(num1 > num2)){
                fulfilled = 0;
            }
        } else if(type == 0){
            if(!(num1 < num2)){
                fulfilled = 0;
            }
        } else {
            err(18, "Error");
        }

        if(!fulfilled){
            if(lseek(data, (off_t)offset1, SEEK_SET) < 0){
                err(13, "Lseek");
            }

            if(write(data, &num2, sizeof(num2)) < 0){
                err(14, "Write");
            }

            if(lseek(data, (off_t)offset2, SEEK_SET) < 0){
                err(15, "Lseek");
            }

            if(write(data, &num1, sizeof(num1)) < 0){
                err(16, "Write");
            }
        }
    }

    if(close(data) < 0 || close(compare) < 0){
        err(17, "Close");
    }

    exit(0);
}


~~~~~~~~~~~~~~ C/Sbornik/Input_output/2020-IN-01/main.c ~~~~~~~~~~~~~~

#include <fcntl.h>
#include <err.h>
#include <unistd.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdbool.h>


int main(int argc, const char* argv[])
{
    if(argc != 4){
        err(1, "Error");
    }

    int fd1 = open(argv[1], O_RDONLY);
    int fd2 = open(argv[2], O_RDONLY);
    int fd3 = open(argv[3], O_WRONLY | O_CREAT | O_TRUNC, 0644);

    if(fd1 < 0 || fd2 < 0 || fd3 < 0){
        err(1, "Error");
    }

    char buff[4096];
    while(read(fd2, buff, sizeof(buff)) > 0)
    {
        if(write(fd3, buff, strlen(buff)) < 0){
            err(1, "Error");
        }
    }

    int fd2Size = lseek(fd2, 0, SEEK_END);
    if(fd2Size < 0){
        err(1, "Size");
    }

    if(lseek(fd2, 0, SEEK_SET) < 0){
        err(1, "Error");
    }

    uint32_t magic;
    uint8_t headerV;
    uint8_t dataV;
    uint16_t count;

    if(read(fd1, &magic, sizeof(magic)) < 0 || read(fd1, &headerV, sizeof(headerV)) < 0 || read(fd1, &dataV, sizeof(dataV)) < 0 || read(fd1, &count, sizeof(count)) < 0){
        err(1, "Error");
    }

    if(magic != 0xEFBEADDE || headerV != 0x01){
        err(1, "File");
    }

    if(lseek(fd1, 8, SEEK_CUR) < 0){
        err(1, "Error");
    }

    for(int i = 0; i < count; i++)
    {
        if(dataV == 0)
        {
            uint16_t offset;
            uint8_t orgB, newB, oldB;

            if(read(fd1, &offset, sizeof(offset)) < 0 || read(fd1, &orgB, sizeof(orgB)) < 0 || read(fd1, &newB, sizeof(newB)) < 0){
                err(1, "Patch");
            }

            if((int)offset >= fd2Size){
                err(1, "Diff sizes");
            }

            if(lseek(fd2, offset, SEEK_SET) < 0){
                err(1, "Error");
            }

            if(read(fd2, &oldB, sizeof(oldB)) < 0){
                err(1, "Error");
            }

            if(oldB != orgB){
                err(1, "Error");
            }

            if(lseek(fd3, offset, SEEK_SET) < 0){
                err(1, "Error");
            }

            if(write(fd3, &newB, sizeof(newB)) < 0){
                err(1, "Error");
            }
        }
        else if(dataV == 1)
        {
            //same like the case where dataV == 0 but offset is uit32_t and orgB, newB, oldB are uint16_t
        }
    }

    exit(0);
}


~~~~~~~~~~~~~~ C/Sbornik/Input_output/2017-SE-02/main.c ~~~~~~~~~~~~~~

#include <fcntl.h>
#include <err.h>
#include <unistd.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdbool.h>

void printNum(int num)
{
    char buff[16];
    snprintf(buff, sizeof(buff), "%d ", num);
    if(write(1, buff, strlen(buff)) < 0)
    {
        err(1, "Error");
    }
}

void processFile(int fd, bool printNumber)
{
    int num = 1;
    char c;
    char prev = '\n';
    int flag;
    while((flag = read(fd, &c, sizeof(c))) > 0)
    {
        if(printNumber && prev == '\n')
        {
            printNum(num);
        }

        if(write(1, &c, sizeof(c)) < 0){
            err(1, "Error");
        }

        if(c == '\n')
        {
            num++;
        }
        prev = c;
    }

    if(flag < 0){
        err(1, "Error");
    }
}

void readFromSTDIN(bool isNumbered)
{
    char c;
    char prev = '\n';
    int num = 1;
    int flag;

    while((flag = read(0, &c, sizeof(c))) > 0)
    {
        if(prev == '\n')
        {
            if(c == '\n')
            {
                break;
            }
            else if(isNumbered)
            {
                printNum(num);
            }
        }

        if(write(1, &c, sizeof(c)) < 0){
            err(1, "Error");
        }

        if(c == '\n')
        {
            num++;
        }
        prev = c;
    }

    if(flag < 0){
        err(1, "Error");
    }
}


int main(int argc, const char* argv[])
{
    if(argc == 1)
    {
        readFromSTDIN(0);
    }

    bool isNumbered = 0;
    if(strcmp(argv[1], "-n") == 0)
    {
        isNumbered = 1;
    }

    for(int i = 1; i < argc; i++)
    {
        if(isNumbered && i == 1)
        {
            continue;
        }

        if(strcmp(argv[i], "-") == 0)
        {
            readFromSTDIN(isNumbered);
        }
        else
        {
            int fd = open(argv[i], O_RDONLY);
            if(fd < 0){
                err(1, "Error");
            }

            processFile(fd, isNumbered);
            if(close(fd) < 0){
                err(1, "Error");
            }
        }
    }
    exit(0);
}


~~~~~~~~~~~~~~ C/Sbornik/Input_output/2020-SE-01/main.c ~~~~~~~~~~~~~~

#include <fcntl.h>
#include <err.h>
#include <unistd.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdbool.h>

int main(int argc, const char* argv[])
{
    if(argc != 7){
        err(1, "Error");
    }

    int aff = open(argv[1], O_RDONLY);
    if(aff < 0){
        err(1, "Error");
    }
    int post = open(argv[2], O_RDONLY);
    if(post < 0){
        err(1, "Error");
    }
    int pref = open(argv[3], O_RDONLY);
    if(pref < 0){
        err(1, "Error");
    }
    int inf = open(argv[4], O_RDONLY);
    if(inf < 0){
        err(1, "Error");
    }
    int suff = open(argv[5], O_RDONLY);
    if(suff < 0){
        err(1, "Error");
    }
    int cruci = open(argv[6], O_TRUNC | O_CREAT | O_WRONLY, 0644);
    if(cruci < 0){
        err(1, "Error");
    }

    uint16_t sizes[5];
    if(lseek(aff, 4, SEEK_SET) < 0 || lseek(post, 4, SEEK_SET) < 0 || lseek(pref, 4, SEEK_SET) < 0 || lseek(inf, 4, SEEK_SET) < 0 || lseek(suff, 4, SEEK_SET) < 0)
    {
        err(1, "Error");
    }

    if(read(aff, &sizes[0], sizeof(sizes[0])) < 0 || read(post, &sizes[1], sizeof(sizes[1])) < 0 || read(pref, &sizes[2], sizeof(sizes[2])) < 0 ||
        read(inf, &sizes[3], sizeof(sizes[3])) < 0 || read(suff, &sizes[4], sizeof(sizes[4])) < 0)
    {
        err(2, "Error");
    }

    uint8_t firstBytes[16];
    if(read(aff, firstBytes, sizeof(firstBytes)) < 0){
        err(1, "Error");
    }
    if(write(cruci, firstBytes, sizeof(firstBytes)) < 0){
        err(1, "Error");
    }

    uint16_t elsCount = 0;

    int complects = sizes[0] / 4;
    for(int i = 0; i < complects; i++)
    {
        uint16_t intervals[8];
        if(read(aff, intervals, sizeof(intervals)) < 0){
            err(1, "Error");
        }

        elsCount += (intervals[1] + intervals[3] + intervals[5] + intervals[7]);

        if(lseek(post, intervals[0], SEEK_SET) < 0){
            err(1, "Error");
        }
        for(int j = 0; j < intervals[1]; j++)
        {
            uint32_t curr;
            if(read(post, &curr, sizeof(curr)) < 0){
                err(1, "Error");
            }
            if(write(cruci, &curr, sizeof(curr)) < 0){
                err(1, "Error");
            }
        }

        if(lseek(pref, intervals[2], SEEK_SET) < 0){
            err(1, "Error");
        }
        for(int j = 0; j < intervals[3]; j++)
        {
            uint8_t curr;
            if(read(pref, &curr, sizeof(curr)) < 0){
                err(1, "Error");
            }
            if(write(cruci, &curr, sizeof(curr)) < 0){
                err(1, "Error");
            }
        }

        if(lseek(inf, intervals[4], SEEK_SET) < 0){
            err(1, "Error");
        }
        for(int j = 0; j < intervals[5]; j++)
        {
            uint16_t curr;
            if(read(inf, &curr, sizeof(curr)) < 0){
                err(1, "Error");
            }
            if(write(cruci, &curr, sizeof(curr)) < 0){
                err(1, "Error");
            }
        }

        if(lseek(suff, intervals[6], SEEK_SET) < 0){
            err(1, "Error");
        }
        for(int j = 0; j < intervals[7]; j++)
        {
            uint64_t curr;
            if(read(suff, &curr, sizeof(curr)) < 0){
                err(1, "Error");
            }
            if(write(cruci, &curr, sizeof(curr)) < 0){
                err(1, "Error");
            }
        }
    }

    if(lseek(cruci, 4, SEEK_SET) < 0){
        err(1, "Error");
    }
    if(write(cruci, &elsCount, sizeof(elsCount)) < 0){
        err(1, "Error");
    }

    if(close(aff) < 0 || close(suff) < 0 || close(cruci) < 0 || close(inf) < 0 || close(pref) < 0 || close(post) < 0){
        err(1, "Error");
    }

    exit(0);
}


~~~~~~~~~~~~~~ C/Sbornik/Input_output/2021-SE-03/main.c ~~~~~~~~~~~~~~

#include <fcntl.h>
#include <err.h>
#include <unistd.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdbool.h>

const uint32_t MAX_SIZE = 524288;

int main(int argc, const char* argv[])
{
    if(argc != 3){
        err(1, "Incorrect input");
    }

    int input = open(argv[1], O_RDONLY);
    if(input < 0){
        err(2, "Open");
    }

    int header = open(argv[2], O_CREAT | O_TRUNC | O_WRONLY, 0644);
    if(header < 0){
        err(2, "Open");
    }


    uint32_t arrSize = lseek(input, 0, SEEK_END);
    if(arrSize <= 0){
        err(3, "Seek");
    }
    arrSize /= sizeof(uint16_t);

    if(arrSize > MAX_SIZE)
    {
        err(1, "Max array size exceeded");
    }

    if(lseek(input, 0, SEEK_SET) < 0){
        err(3, "Seek");
    }

    char code[32] = "#pragma once\n";
    if(write(header, code, strlen(code)) < 0){
        err(4, "Write");
    }

    char code1[64];
    snprintf(code1, sizeof(code1), "const uint32_t arrN = %u;\n", arrSize);
    if(write(header, code1, strlen(code1)) < 0){
        err(4, "Write");
    }

    char code2[64] = "const uint16_t arr[] = { ";
    if(write(header, code2, strlen(code2)) < 0){
        err(4, "Write");
    }

    for(uint32_t i = 0; i < arrSize; i++)
    {
        uint16_t num;
        if(read(input, &num, sizeof(num)) < 0){
            err(5, "Read");
        }

        char number[16];
        if(i == arrSize - 1)
        {
            snprintf(number, sizeof(number), "%u };\n", num);
        }
        else
        {
            snprintf(number, sizeof(number), "%u,\n", num);
        }

        if(write(header, number, strlen(number)) < 0){
            err(4, "Write");
        }
    }

    if(close(input) < 0 || close(header) < 0){
        err(6, "Close");
    }

    exit(0);
}


~~~~~~~~~~~~~~ C/Sbornik/Input_output/2017-SE-01/main.c ~~~~~~~~~~~~~~

#include <fcntl.h>
#include <err.h>
#include <unistd.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdbool.h>

int main(int argc, const char* argv[])
{
    if(argc != 4){
        err(1, "File needs 3 files");
    }

    int fd1 = open(argv[1], O_RDONLY);
    if(fd1 < 0){
        err(1, "Error");
    }
    int fd2 = open(argv[2], O_RDONLY);
    if(fd2 < 0){
        err(1, "Error");
    }
    int fd3 = open(argv[2], O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if(fd3 < 0){
        err(1, "Error");
    }

    off_t f1Size = lseek(fd1, 0, SEEK_END);
    off_t f2Size = lseek(fd2, 0, SEEK_END);
    if(f1Size <= 0 || f2Size <= 0){
        err(1, "Error");
    }

    if(f1Size != f2Size){
        err(1, "Files have different sizes");
    }

    uint16_t offset = 0;
    uint8_t byte1;
    uint8_t byte2;
    int flag;

    while((flag = read(fd1, &byte1, sizeof(byte1))) > 0 && (flag = read(fd2, &byte2, sizeof(byte2))) > 0)
    {
        if(write(fd3, &offset, sizeof(offset)) < 0){
            err(1, "Error");
        }
        if(write(fd3, &byte1, sizeof(byte1)) < 0){
            err(1, "Error");
        }
        if(write(fd3, &byte2, sizeof(byte2)) < 0){
            err(1, "Error");
        }

        offset++;
    }

    if(close(fd1) < 0 || close(fd2) < 0 || close(fd3) < 0){
        err(1, "Error");
    }

    exit(0);
}


~~~~~~~~~~~~~~ C/Sbornik/Input_output/2016-SE-02/main.c ~~~~~~~~~~~~~~

#include <fcntl.h>
#include <err.h>
#include <unistd.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

int main(int argc, const char* argv[])
{
    if(argc != 4){
        err(1, "Not enough files");
    }

    int fd1 = open(argv[1], O_RDONLY);
    if(fd1 < 0){
        err(1, "Err");
    }
    int fd2 = open(argv[2], O_RDONLY);
    if(fd2 < 0){
        err(1, "Err");
    }
    int fd3 = open(argv[3], O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if(fd3 < 0){
        err(1, "Err");
    }

    off_t fd1Size = lseek(fd1, 0, SEEK_END);
    off_t fd2Size = lseek(fd2, 0, SEEK_END);
    if(fd1Size <= 0 || fd2Size <= 0){
        err(1, "One or both of the input files are empty");
    }

    if(lseek(fd1, 0, SEEK_SET) < 0){
        err(1, "Err");
    }

    uint32_t beg;
    uint32_t length;
    int isOk;

    while((isOk = read(fd1, &beg, sizeof(beg))) > 0 && (isOk = read(fd1, &length, sizeof(length))) > 0)
    {
        if((off_t)(beg * 4) > fd2Size){
            err(1, "Err");
        }

        if(lseek(fd2, beg * 4, SEEK_SET) < 0){
            err(1, "err");
        }

        for(int i = 0; i < (int)length; i++)
        {
            uint32_t num;
            if(read(fd2, &num, sizeof(num)) < 0){
                err(1, "Err");
            }

            char buff[16];
            snprintf(buff, sizeof(buff), "%u", num);
                err(1, "Err");
            }

            if((size_t)write(fd3, buff, strlen(buff)) != strlen(buff)){
                err(1, "Error");
            }
        }
    }

    if(close(fd1) < 0 || close(fd2) < 0 || close(fd3) < 0){
        err(1, "Error");
    }
    exit(0);
}


~~~~~~~~~~~~~~ C/Sbornik/Input_output/2016-SE-01/main.c ~~~~~~~~~~~~~~

#include <fcntl.h>
#include <err.h>
#include <unistd.h>
#include <stdint.h>
#include <stdlib.h>

int main(int argc, const char* argv[])
{
    if(argc != 2){
        err(1, "Binary file needed.");
    }

    int bytes[256];
    for(int i = 0; i < 256; i++){
        bytes[i] = 0;
    }

    int fd = open(argv[1], O_RDWR);
    if(fd < 0){
        err(1, "Couldn't open file");
    }

    uint8_t c;
    int byteRead;
    while((byteRead = read(fd, &c, sizeof(c))) > 0)
    {
        bytes[c]++;
    }

    if(byteRead < 0){
        err(1, "Error while reading");
    }

    if(lseek(fd, 0, SEEK_SET) < 0){
        err(1, "Couldn't reset position");
    }

    for(int i = 0; i < 256; i++)
    {
        for(int j = 0; j < bytes[i]; j++)
        {
            c = i;
            if(write(fd, &c, sizeof(c)) != sizeof(c)){
                err(1, "Couldn't write to file");
            }
        }
    }

    if(close(fd) < 0){
        err(1, "Couldn't close file");
    }

    exit(0);
}


~~~~~~~~~~~~~~ C/Sbornik/Input_output/2019-SE-01/main.c ~~~~~~~~~~~~~~

#include <fcntl.h>
#include <err.h>
#include <unistd.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdbool.h>

void updateRecord(uint32_t longestSessions[], int idx, uint32_t newRec)
{
    if(longestSessions[idx] < newRec)
    {
        longestSessions[idx] = newRec;
    }
}

int findIndex(uint32_t ids[], int idIndex, uint32_t id)
{
    for(int i = 0; i <= idIndex; i++)
    {
        if(ids[i] == id)
        {
            return i;
        }
    }

    return -1;
}


int main(int argc, const char* argv[])
{
    if(argc != 2){
        err(1, "Error");
    }

    uint32_t records[16384];
    uint32_t IDs[2048];
    uint32_t longestSessions[2048] = {0};

    int recsInd = 0;
    int idInd = 0;
    int lngSessInd = 0;

    int fd = open(argv[1], O_RDONLY);

    double avg = 0;
    int N = 0;

    uint32_t data[4];
    int readBytes;

    while((readBytes = read(fd, data, sizeof(data))) > 0)
    {
        uint32_t currSess = data[3] - data[2];
        int index = findIndex(IDs, idInd, data[0]);
        if(index == -1)
        {
            IDs[idInd] = data[0];
            longestSessions[lngSessInd] = currSess;
            idInd++;
            lngSessInd++;
        }
        else
        {
            updateRecord(longestSessions, index, currSess);
        }

        records[recsInd] = currSess;
        recsInd++;
        avg += currSess;
        N++;
    }

    if(readBytes < 0){
        err(1, "Error");
    }

    avg /= N;

    long double disp = 0;
    for(int i = 0; i <= recsInd; i++)
    {
        disp += ((records[i] - avg) * (records[i] - avg));
    }
    disp /= N;

    for(int i = 0; i <= idInd; i++)
    {
        if((longestSessions[i] * longestSessions[i]) > disp)
        {
            char info[128];
            snprintf(info, sizeof(info), "UID: %u, longest session: %u", IDs[i], longestSessions[i]);
            if(write(1, info, strlen(info)) < 0){
                err(1, "Error");
            }
        }
    }

    if(close(fd) < 0){
        err(1, "Error");
    }

    exit(0);
}


~~~~~~~~~~~~~~ C/Sbornik/Input_output/2017-SE-03/main.c ~~~~~~~~~~~~~~

#include <fcntl.h>
#include <err.h>
#include <unistd.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdbool.h>

int main(int argc, const char* argv[])
{
    if(argc != 4){
        err(1, "Not enough args");
    }

    int fd1 = open(argv[1], O_RDONLY);
    if(fd1 < 0){
        err(1, "Error");
    }
    int fd2 = open(argv[2], O_RDONLY);
    if(fd2 < 0){
        err(1, "Error");
    }
    int fd3 = open(argv[3], O_RDWR | O_TRUNC | O_CREAT, 0644);
    if(fd3 < 0){
        err(1, "Error");
    }

    int fd2Size = lseek(fd2, 0, SEEK_END);
    if(fd2Size < 0){
        err(1, "Error");
    }

    if(lseek(fd2, 0, SEEK_SET) < 0){
        err(1, "Error");
    }

    char buff[2048];
    int bytesTransf;

    while((bytesTransf = read(fd2, buff, sizeof(buff))) > 0)
    {
        if(write(fd3, buff, bytesTransf) < 0){
            err(1, "Error");
        }
    }

    int readBytes;
    uint16_t offset;
    uint8_t orgByte;
    uint8_t newByte;
    uint8_t file1Byte;

    while((readBytes = read(fd1, &offset, sizeof(offset))) > 0 && (readBytes = read(fd1, &orgByte, sizeof(orgByte))) > 0 &&
            (readBytes = read(fd1, &newByte, sizeof(newByte))) > 0)
    {
        if((int)offset < fd2Size)
        {
            if(lseek(fd3, offset, SEEK_SET) < 0)
            {
                err(1, "Error while changin position to file 2");
            }

            if(lseek(fd2, offset, SEEK_SET) < 0){
                err(1, "Error");
            }

            if(read(fd2, &file1Byte, sizeof(file1Byte)) < 0){
                err(1, "Error");
            }

            if(file1Byte == orgByte){
                if(write(fd3, &newByte, sizeof(newByte)) < 0){
                    err(1, "Error while reading in file 2");
                }
            }
            else{
                err(1, "Bytes mismatch");
            }
        }
    }

    if(readBytes < 0){
        err(1, "Error while reading from patch");
    }

    if(close(fd1) < 0 || close(fd2) < 0 || close(fd3) < 0){
        err(1, "Error");
    }

    exit(0);
}
