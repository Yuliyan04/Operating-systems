~~~~~~~~~~~~~~Task: 2017SE02.sh~~~~~~~~~~~~~~

#!/bin/bash

if [[ ${#} -ne 3 ]];
then
echo "Script takes 3 arguments..." >&2
exit 2
fi

if [[ ! -d "${1}" || ! -d "${2}" ]];
then
echo "Arguments are not directories..." >&2
exit 2
fi

if [[ -n "$( find "${2}" -mindepth 1 )" ]];
then
echo "The second directory must be empty..." >&2
exit 2
fi

if [[ -z "$( find "${1}" -mindepth 1)" ]];
then
echo "The first directory must not be mepty..." >&2
exit 2
fi

if [[ "$(whoami)" != "root" ]];
then
echo "To use this script you must be root..." >&2
exit 2
fi

while read -r file;
do
dirs=$( dirname "${file}" | cut -d '/' -f 2- );
dir1=$( basename "${1}" )

if [[ "${dirs}" != "${dir1}" ]];
then
mkdir -p "${2}/${dirs}"
mv "${file}" "${2}/${dirs}"

else
mv "${file}" "${2}"
fi
done < <(find "${1}" -mindepth 1 -maxdepth 2 -name "*${3}*" )

exit 0



~~~~~~~~~~~~~~Task: 2017IN03.sh~~~~~~~~~~~~~~

#!/bin/bash

tempFile=$(mktemp)

while read -r homeDir;
do
echo "done"
if [[ -d "${homeDir}" ]];
then
curr=$(find "${homeDir}" -type f -exec stat -c "%n %Y" {} \; 2>/dev/null | sort -t ' ' -k 2 -n -r | head -n 1)
if [[ -n "$curr" ]]; then
echo "${curr} ${homeDir}" >> "${tempFile}"
fi
else
continue
fi
done < <(cut -d ':' -f 6 /etc/passwd | grep -E -v "nologin")

cat "${tempFile}" | sort



~~~~~~~~~~~~~~Task: 2017SE04.sh~~~~~~~~~~~~~~

#!/bin/bash

if [[ ${#} -lt 1 || ${#} -gt 2 ]];
then
echo "Script needs 1 or 2 arguments..." >&2
exit 2
fi

if [[ ! -d "${1}" ]];
then
echo "First argument must be a directory..." >&2
exit 2
fi

count=0

while read -r file;
do
isBroken=$( readlink -e "${file}" )
if [[ -z "${isBroken}" ]];
then
count=$(( count + 1 ))
continue
fi

if [[ -z "${2}" ]];
then
echo "${file} -> ${isBroken}"
else
echo "${file} -> ${isBroken}" > "${2}"
fi
done < <( find "${1}" -mindepth 1 -maxdepth 2 -type l )

if [[ -z "${2}" ]];
then
echo "Broken symlinks: ${count}"
else
echo "Broken symlinks: ${count}" > "${2}"
fi

exit 0



~~~~~~~~~~~~~~Task: 2017SE03.sh~~~~~~~~~~~~~~

#!/bin/bash

if [[ "$( whoami )" == "root" ]];
then
echo "To use this script you must be root..." >&2
exit 2;
fi

#get the sum of rss for every user and processes count

echo "$( ps -e -o user,rss --no-header )" | tr -s ' ' | awk -F ' ' ' { mem[$1] += $2; count[$1] += 1 } END { for ( key in mem ) { print key, mem[key], count[key] } } '

avgUserRSS=$(  echo "$( ps -e -o user,rss --no-header )" | tr -s ' ' | awk -F ' ' ' { mem[$1] += $2; count[$1] += 1 } END { for ( key in mem ) { print key, mem[key] / count[key] } } ' )

while read -r user;
do
psRSS=$( echo "${user}" | cut -d ' ' -f 2 )
username=$( echo "${user}" | cut -d ' ' -f 1 )

ps=$( ps -u "${username}" -o pid,rss | sort -t ' ' -k 2 -n -r | head -n 1 )
psM=$( echo "${ps}" | cut -d ' ' -f 2 )
pID=$( echo "${ps}" | cut -d ' ' -f 1)

if [[ -n "$pID" ]] && (( $( echo "${psRSS} * 2 <  ${psM}" | bc -l ) ));
then
echo "kill ${pID}"
fi
done < <( echo "${avgUserRSS}" )
exit 0



~~~~~~~~~~~~~~Task: 2017SE06.sh~~~~~~~~~~~~~~




~~~~~~~~~~~~~~Task: 2017IN01.sh~~~~~~~~~~~~~~

#!/bin/bash

if [[ ${#} -ne 3 ]];
then
echo "Script needs 3 arguments..."
exit 2
fi

key1=$( grep -E "${2}" "${1}" | cut -d '=' -f 2 | tr ' ' '\n' | sort )
key2=$( grep -E "${3}" "${1}" | cut -d '=' -f 2 | tr ' ' '\n' | sort )

newVals=$( comm <(echo "${key1}") <(echo "${key2}") -1 -3 | tr '\n' ' ' )

sed -E -i "s/${3}=.*/${3}=${newVals}/g" "${1}"
exit 0



~~~~~~~~~~~~~~Task: 2017IN02.sh~~~~~~~~~~~~~~

#!/bin/bash

if [[ ${#} -ne 1 ]];
then
echo "Script needs 1 argument..."
exit 2
fi

if [[ ${1} == "root" ]];
then
echo "To use this script you must be root..."
exit 2
fi

fooPS=$(ps -u ${1} | wc -l)
while read -r user;
do
currPS=$(ps -u ${user} 2>/dev/null | wc -l)
if [[ ${currPS} -gt ${fooPS} ]];
then
echo "Username: ${user}"
fi
done < <( ps -A -o user | sort | uniq )
echo " "

table=$( ps -e -o user,pid,time | tail -n +2 | tr -s ' ' | tr ' ' ':' )
avTime=$( echo "$table" | awk -F':' ' BEGIN { avTime = 0; count = 0; } { avTime += ( $3 * 3600 + $4 * 60 + $5 ); count += 1; } END { print avTime / count } ' )
echo "Average time: ${avTime}"

doubleAvTime=$( echo "${avTime} * 2" | bc )
while read -r process;
do
currP=$( echo "process" | awk ' BEGIN { time = 0 } { time += ($2 * 3600 + $3 * 60 + $4)} END { print time} ' )
if (( $(echo "$currP > $doubleAvTime" | bc -l) ));
then
echo "Kill $(cut -d ':' -f 1 ${process})"
fi
done < <(ps -u ${1} -o pid,time | tr -s ' ' | tr ' ' ':')



~~~~~~~~~~~~~~Task: 2017SE05.sh~~~~~~~~~~~~~~

#!/bin/bash

if [[ ${#} -ne 2 ]];
then
echo "Script needs 2 arguments..." >&2
exit 2
fi

if [[ ! -d "${1}" ]];
then
echo "The first argument must be a directory..." >&2
fi

find "${1}" -mindepth 1 -maxdepth 1 -type f | grep -E "vmlinuz-[0-9]+\.[0-9]+\.[0-9]+-${2}" | sort -t '-' -k 2 -n -r | head -n 1



~~~~~~~~~~~~~~Task: 2017SE01.sh~~~~~~~~~~~~~~

#!/bin/bash

if [[ ${#} -lt 1 || ${#} -gt 2 ]];
then
echo "This script takes one parameter(directory) and optional one(num)..." >2
exit 2
fi

if [[ ${#} -eq 2 ]];
then
files=$( find "${1}" -mindepth 1 -exec stat -c "%h %n \n" {} \; )
while read -r file;
do
count=$(echo "${file}" | cut -d ' ' -f 1)
if [[ ${count} -gt ${2} ]];
then
echo "$(echo "${file}" | cut -d ' ' -f 2)"
fi
done < <(echo "${files}")
else
files=$( find "${1}" -mindepth 1 -type l )
while read -r file;
do
curr=$( readlink -e "${file}" )
if [[ -z ${curr} ]];
then
echo "${file}"
fi
done < <(echo "${files}")
fi

exit 0



~~~~~~~~~~~~~~Task: 2019SE03.sh~~~~~~~~~~~~~~

#!/bin/bash


if [[ ${#} -ne 1 ]];
then
echo "Ecript needs 1 parameter...." >&2
exit 2
fi

if [[ ! -d ${1} ]];
then
echo "File meust be directory" >&2
exit 2
fi

if ! find "${1}" -mindepth 1 -name "modified.txt";
then
touch "${1}/modified.txt"
fi


while read -r file;
do
filename=$( basename "${file}" | grep -E "^[^_]+_report-[0-9]+\.tgz$" )
if [[ -z "${filename}" ]];
then
continue
fi

coded=$( sha256sum "${file}" )
isMod=$( grep -E "${coded}" "${1}/modified.txt" | cut -d ' ' -f 1 )

if [[ "${coded}" == "${isMod}" ]];
then
continue
else
if [[ -n "$( tar -tzf "${file}" | grep -E "meow.txt" )" ]];
then
name=$( echo "${filename}" | cut -d '_' -f 1 )
time=$( echo "${filename}" | cut -d '-' -f 2 | cut -d '.' -f 1 )
dir=$(mktemp -d)
tar -xzf "${file}" -C "${dir}"
mv "${dir}/meow.txt" "${dir}/${name}_${time}"
tar -czf "${file}" -C "${dir}"
rm -r "${dir}"

if [[ -z "${isMod}" ]];
then
echo "${coded}" >> "${1}/modified"
else
sed -i "s/${isMod}  ${file}/${coded}/" "${1}/modified.txt"
fi
fi
fi
done < <( find "${1}" -mindepth 1 )

exit 0



~~~~~~~~~~~~~~Task: 2019SE02.sh~~~~~~~~~~~~~~

#!/bin/bash

if [[ ${#} -eq 0 ]];
then
echo "Scripts needs atleast 1 argument..." >&2
exit 2
fi

N=10
if [[ "${1}" == "-n" ]];
then
N=${2}
fi

tempFile=$(mktemp)


for file in "${@}";
do
if [[ "${1}" == "-n" ]] && [[ "${file}" == "${1}" || "${file}" == "${2}" ]];
then
continue
fi

while read -r line;
do
timeStamp=$( echo "${line}" | cut -d ' ' -f 1,2 )
interval1=$( echo "${line}" | cut -d ' ' -f 3 )
interval2=$( echo "${line}" | cut -d ' ' -f 4 )
idf=$( basename "${file}" | cut -d '.' -f 1 )
data=$( echo "${line}" | cut -d ':' -f 2)

echo "${timestamp} ${interval1} ${idf} ${interval2} ${data}" >> "${tempFile}"
done < <( cat "${file}" | tail -n ${N} )
done

cat "${tempFile}" | sort -t ' ' -k 1 -n
rm "${mkTemp}"
exit 0



~~~~~~~~~~~~~~Task: 2019SE011.sh~~~~~~~~~~~~~~




~~~~~~~~~~~~~~Task: 2019SE012.sh~~~~~~~~~~~~~~

#!/bin/bash


if [[ ${#} -ne 0 ]];
then
echo "Scripts doesn't need arguments..." >&2
exit 2
fi

tempFile=$(mktemp)

while read  num;
do
if [[ -n "${num}" ]];
then
digitsSum=$( echo "${num}" | tr -d '-' | grep -o . | awk -F '\n' ' BEGIN { sum = 0 } { sum += $1 } END { print sum } ' )
echo "${num},${digitsSum}" >> "${tempFile}"
else
break
fi
done

sorted=$( cat "${tempFile}" | sort -t ',' -k 1 -n | uniq | sort -t ',' -k 1 -k 2 -n -r )
max=$( echo "${sorted}" | head -n 1 )

while read -r num;
do
if [[ $( echo "${num}" | cut -d ',' -f 2 ) -eq ${max} ]];
then

done < <( echo "${sorted}" )
rm "${tempFile}"



~~~~~~~~~~~~~~Task: 2023SE04.sh~~~~~~~~~~~~~~

#!/bin/bash

if [[ ${#} -ne 1 ]];
then
echo "error"
exit 1
fi

files=$( mktemp )

while read -r file;
do
shaSum=$( sha256sum "$file" | tr -s '[:space:]' ' ' )
echo "$shaSum" >> "$files"
done < <( find "$1" -mindepth 1 -type f )

uniqSHA=$( cat "$files" | cut -d ' ' -f 1 | sort | uniq )
filesToSave=$( mktemp )

while read -r sha;
do
if grep -Eq "$sha" "$filesToSave"; then
continue
fi

file=$( grep -E "$sha" "$files" | head -n 1 )
echo "$file" >> "$filesToSave"
done < <( echo "$uniqSHA" )

savedBytes=0

while read -r file;
do
filename=$( echo "$file" | cut -d ' ' -f 2- )
parent=$( grep -E "$( echo "$file" | cut -d ' ' -f 1 )" "$filesToSave" | cut -d ' ' -f 2- )

if [[ "$filename" == "$parent" ]]; then
continue
fi

savedBytes=$(( $savedBytes + $( cat "$filename" | wc -c ) ))
rm "$filename"
ln "$parent" "$filename"
done < "$files"

echo "Dedublicated groups of files: $( cat "$filesToSave" | wc -l )"
echo "Saved space: ${savedBytes} bytes"

rm $files $filesToSave



~~~~~~~~~~~~~~Task: 2023SE02.sh~~~~~~~~~~~~~~

#!/bin/bash

if [[ ${#} -eq 0 ]];
then
echo "error"
exit 1
fi

seconds=$1
args=$( mktemp )
for arg in "${@}";
do
if [[ "$arg" == "$1" ]]; then
continue
fi

echo "$arg" >> "$args"
done

command=$( cat "$args" | tr '\n' ' ' | rev | cut -c 2- | rev )
bound=$(( $( date +%s ) + $seconds ))
count=0
time=0
startTime=$( date +%s )

while [[ $( date +%s ) -lt $bound ]];
do
eval "${command}"
count=$(( $count + 1 ))
time="$(( $( date +%s ) - $startTime )).$( date +%N )"
done

echo "Ran the command: ${command} for ${count} times in ${time} seconds."
exit 0



~~~~~~~~~~~~~~Task: 2023SE01.sh~~~~~~~~~~~~~~

#!/bin/bash

if [[ ${#} -ne 2 ]];
then
echo "error"
exit 1
fi

if [[ ! -d "$2" ]];
then
echo "error"
exit 1
fi

while read -r file;
do
while read -r word;
do
censored=$( echo "$word" | grep -E -o "." | tr '[:alpha:]' '*' | tr -d '\n' )
sed -E -i "s/\b${word}\b/${censored}/g" "$file"
done < "$1"
done < <( find "${2}" -type f -name "*.txt" )

exit 0



~~~~~~~~~~~~~~Task: 2023SE03.sh~~~~~~~~~~~~~~

#!/bin/bash

if [[ ${#} -ne 1 ]]; then
echo "error"
exit 1
fi

words=$(mktemp)
allFiles=$( find "$1" -mindepth 1 -type f )

while read -r file;
do
cat "$file" | tr [:punct:] ' ' | tr [:digit:] ' ' | tr '\n' ' ' | tr -s [:space:] | tr ' ' '\n' | sort | uniq -c | tr -s [:space:] | cut -c 2- | grep -E "^[0-9]+ [a-zA-Z]{2,}$" >> "$words"
done < <( find "$1" -mindepth 1 -type f )

allFilesWords=$( mktemp )
awk -F ' ' '{ count[$2] += $1 } END { for ( word in count ) { print word, count[word] } }' "$words" >> "$allFilesWords"
uniqWords=$( cut -d ' ' -f 1 "$allFilesWords" | sort | uniq )

res=$( mktemp )
while read -r word;
do
fileOccurs=$( grep -E "$word" "$words" | awk -F ' ' '$1 >= 3 { print $2 }' | wc -l )
sum=$( grep -E "$word" "$allFilesWords" | cut -d ' ' -f 2 )
if [[ $(( $fileOccurs + $fileOccurs )) -ge $allFiles ]];
then
echo "${word} ${sum}"
fi
done < <( echo "$uniqWords" )

cat "$res" | sort -t ' ' -k 2 -n -v | head -n 10
rm $words $allFilesWords $res
exit 0



~~~~~~~~~~~~~~Task: 2023SE06.sh~~~~~~~~~~~~~~

#!/bin/bash

if [[ ${#} -ne 2 ]];
then
echo "error"
exit 1
fi

if [[ -d "$2" ]];
then
echo "Library already exists"
exit 1
fi

mkdir "./$2"
photos=$( mktemp )

while read -r photo;
do
picName=$( $basename "$photo" )
lastModTime=$( stat "$photo" -c "%y" | cut -d ' ' -f 1 )
echo "${lastModTime} ${picName}" >> "$photos"
done < <( find "$1" -mindepth 1 -name "*.jpg" )

startPeriod="$( cat "$photos" | sort -t -k 1 -n | head -n 1 | cut -d ' ' -f 1 )"
endPeriod="$( cat "$photos" | sort -t -k 1 -n | head -n 1 | cut -d ' ' -f 1 )"

while read -r info;
do
currDate=$( cat "$info" | cut -d ' ' -f 1 )

if [[ "$currDate" == "$endPeriod" ]]; then
continue
fi

if [[ "$currDate" != "$( date -d "${endPerio} + 1" )" ]];
then
mkdir "./${2}/${startPeriod}_${endPeriod}"
startPeriod="$currDate"
endPeriod=$currDate #change the logic with a new temp file to save the info foer every photo in which directory can be added
fi
endPeriod=$currDate
done < <( cat "$photos" | sort -t ' ' -k 1 -n )

if ! find "./${2}/${startPeriod}_${endPeriod}"; then
mkdir "./${2}/${startPeriod}_${endPeriod}"
fi

while read -r photo;
do
currPhotoDate=$( echo "$photo" | cut -d ' ' -f 1 )
currPhotoName=$( echo "$photo" | cut -d ' ' -f 2 )



done < <( cat "$photos" )









~~~~~~~~~~~~~~Task: 2023SE05.sh~~~~~~~~~~~~~~

#!/bin/bash

if [[ ${#} -ne 0 ]];
then
echo "error"
exit 1
fi


looks=0
PS=$( mktemp )

while ps -e;
do
looks=$(( $looks + 1 ))
currPS=$( ps -e -o comm,rss | tr -s ' ' | awk -F ' ' ' { mem[$1] += $2 } END { for ( key in mem ) mem[key] > 65536 { print key, mem[key] } } ' )
if [[ -z "$currPS" ]];
then
break
else
echo "$currPS" >> "${PS}"
fi

sleep 1
done

commands=$( mktemp )
cat "$PS" | cut -d ' ' -f 1 | sort | uniq -c | tr -s [:space:] >> "$commands"

while read -r comm;
do
count=$( echo "$comm" | cut -d ' ' -f 2 )
if (( $( echo "$count > $looks / 2" | bc -l ) ))
then
echo "$( echo "$comm" | cut -d ' ' -f 3 )"
fi
done < "${commands}"

rm "$PS" "$commands"



~~~~~~~~~~~~~~Task: 2023IN02.sh~~~~~~~~~~~~~~

#!/bin/bash

if [[ ${#} -ne 1 ]];
then
echo "error"
exit 1
fi

storage=$( mktemp )

while read -r file;
do
filename=$( echo "$line" | cut -d ' ' -f 1 )
shaSum=$( sha256sum "$filename" | cut -d ' ' -f 1 )

echo "${file} ${shaSum}" >> "$storage"
done < <( find "${1}" -mindepth 1 -type f -exec stat {} "%n %i\n" )

differentFiles=$( cat "$storage" | cut -d ' ' -f 3 | sort | uniq )

while read -r fileSha;
do
currFiles=$( grep -E "$fileSha" "$storage" | sort -t ' ' -k 2 )
currFilesCount=$( echo "$currFiles" | wc -l )
inode=$( echo "$currFiles" | head -n 1 | cut -d ' ' -f 2 )
inodes=$( echo "$currFiles" | grep -E -o "$inode" | wc -l )

if [[ $inodes -eq $currFilesCount ]];
then
echo "Those files can be deleted: "
echo "$currFiles" | tail -n +2 | cut -d ' ' -f 1
elif [[ $inodes -eq $currFilesCount ]];
then
echo "This file can be deleted: "
echo "$currFiles" | head -n 1 | cut -d ' ' -f 1
else
sortedByInodeCount=$( echo "$currFiles" | cut -d ' ' -f 2 | sort | uniq -c | sort -n )
toRemI=$( echo "$sortedByInodeCode" | head -n 1 | cut -d ' ' -f 2 )
echo "Remove this file: "


done < <( echo "$differentFiles" )


rm $storage



~~~~~~~~~~~~~~Task: 2022IN03.sh~~~~~~~~~~~~~~

#!/bin/bash

if [[ ${#} -lt 2 ]];
then
echo "Error" >&2
exit 1
fi

jar=""
jarFile=""
options=$( mktemp )
args=$( mktemp )

for arg in "${@}";
do
if [[ -n "$jarFile" ]];
then
echo "$arg" >> "$args"
continue
fi

if [[ "$arg" =~ ^-.* ]];
then
if [[ "$arg" == "-jar" ]];
then
jar=$arg
continue
fi

if [[ -n "$jarFile" ]];
then
echo "$arg" >> "$args"
else
echo "$arg" >> "$options"
fi

if [[ "$arg" =~ ^-D.* ]]
then
if [[ -n "$jar" ]];
then
echo "$arg" >> "$options"
else
echo "Error -Dprop=val can't be passed before -jar"
exit 1
fi
fi
else
if [[ -n "$jar" ]];
then
jarFile=$arg
fi

if [[ -n "$jarFile" ]] && [[ "$arg" != "$jarFile" ]];
then
echo "$arg" >> "$args"
fi
fi
done

opts=$( cat "$options" | tr '\n' ' ' | rev | cut -c 2- | rev )
arguments=$( cat "$args" | tr '\n' ' ' | rev | cut -c 2- | rev )

eval "java ${arguments} ${jar} ${jarFile} ${options}"
exit 0



~~~~~~~~~~~~~~Task: 2022SE01.sh~~~~~~~~~~~~~~

#!/bin/bash

if [[ ${#} - ne 1 ]];
then
echo "Error"
exit 1
fi

file="/proc/acpi/wakeup"

while read -r line;
do
if [[ "$line" =~ ^# ]];
then
continue
fi

edited=""

if echo "$line" | grep -E "#";
then
edited=$( echo "$line" | cut -d '#' -f 1 | tr -s [[:space:]] )
else
edited=$line
fi

name=$( echo "$edited" | cut -d ' ' -f 1 )
wantedStatus=$( echo "$edited" | cut -d ' ' -f 3 )
info=$( grep -E "^$name" "$file" | tr -s [[:space:]] )

if [[ -z "$info" ]];
then
echo "The status for ${name} you want to change is not in the file"
continue
fi

currStatus=$( echo "$info" | cut -d ' ' -f 3 | rev | cut -c 2- | rev )

if [[ "$wantedStatus" == "$currStatus" ]];
then
echo "The status you want to change for ${name} is already set!"
continue
else
echo "Changing the status for: ${name} from ${currStatus} to ${wantedStatus}."
echo "$name" >> "$file"
echo "Status changed!"
fi
done < <( cat "${1}" | tr -s [[:space:]] )

exit 0



~~~~~~~~~~~~~~Task: 2020SE03.sh~~~~~~~~~~~~~~

#!/bin/bash

if [[ ${#} -ne 2 ]];
then
echo "Script needs 2 arguments..." >&2
exit 2
fi

packname=$( basename ${2} )
version=$( find "${1}" -mindepth 1 -maxdepth 1 -regex "[0-9.]+")
isIn=$( grep -E "^${packname}-" "${1}/db" | cut -d ' ' -f 2 )

if [[ -z "${isIn}" ]]
then
sha=$( sha256sum "${2}" )
tar -cJf "${2}" "${1}/packages/${sha}.tar.xz"
echo "${packname}-${version} ${sha}" >> "${1}/db"
else
sha=$( sha256sum "${2}" | cut -d ' ' -f 1 )
rm -r "${1}/packages/${isIn}.tar.xz"
tar -cJf "${2}" "${1}/packages/${sha}.tar.xz"
sed -i "s/${packname}[0-9.]+ ${isIn}/${packname}-${version} ${sha}" "${1}/db"
fi

exit 0



~~~~~~~~~~~~~~Task: 2020SE01.sh~~~~~~~~~~~~~~

#!/bin/bash

if [[ ${#} -ne 2 ]];
then
echo "Script needs 2 parameters..." >&2
exit 2
fi

if [[ ! -f "${1}" || ! -d "${2}" ]];
then
echo "The first param must be a filename and the second a directory name..." >&2
exit 2
fi

while read -r file;
do


done < <(find -mindepth 1 -name "*.log")



~~~~~~~~~~~~~~Task: 2020SE02.sh~~~~~~~~~~~~~~

#!/bin/bash

if [[ ${#} -ne 1 ]];
then
echo "File needs 1 argument..." >&2
exit 2
fi

top3=$( cat "${1}" | cut -d ' ' -f 2 | sort | uniq -c | tr -s ' ' | cut -c 2- | sort -t ' ' -k 1 -n -r | head -n 3 )

while read -r site;
do
sitename=$( echo "${site}" | cut -d ' ' -f 2 )
currN2=$( grep -E "^([0-9]+\.{,1})+ ${sitename}.*HTTP/2.0.*\"$" "${1}" | wc -l )
currN=$( grep -E "^([0-9]+\.{,1})+ ${sitename}.*HTTP/[^2].*\"$" "${1}" | wc -l )
echo "${sitename} HTTP/2.0: ${currN2} non-HTTP/2.0: ${currN}"
done < <( echo "${top3}" )

tempFile=$(mktemp)
while read -r request;
do
code=$( echo "${request}" | cut -d ' ' -f 9 )
if [[ ${code} -gt 302 ]];
then
echo "$( echo "${request}" | cut -d ' ' -f 1 )" >> "${tempFile}"
fi
done < "${1}"

#top 5 clients
cat "${tempFile}" | sort -t ' ' -k 1 | uniq -c | sort -n -r | head -n 5

rm "${tempFile}"
exit 0



~~~~~~~~~~~~~~Task: 2020SE06.sh~~~~~~~~~~~~~~

#!/bin/bash

if [[ ${#} -ne 3 ]];
then
echo "wr" >&2
exit 2
fi
i
line=$( grep -E -n "^[ ]*${2}[ ]*=[ ]*${3}[ ]*$" "${1}" )
N=$( echo "${line}" | cut -d ':' -f 1 )
allLines=$( cat "${1}" | wc -l )

tempFile=$(mktemp)

if [[ -z "${line}" ]];
then
echo "${2} = ${3} # added at $(date) by $(whoami)" >> "${1}"
else
cat "${1}" | head -n ${N} >> "${tempFile}"
date=$( date )
user=$( whoami)
sed -i -E "s/^([ ]*${2}[ ]*=[ ]*${3}[ ]*)$/#\1 # edited at ${date} by ${user}/" "${tempFile}"
echo "${2} = ${3} added at ${date} by ${user}" >> "${tempFile}"
cat "${1}" | tail -n $(( ${allLines} - ${N} )) >> ${tempFile}
fi

cat "${tempFile}" > "${1}"
rm "${tempFile}"
exit 0



~~~~~~~~~~~~~~Task: 2020SE05.sh~~~~~~~~~~~~~~

#!/bin/bash

if [[ ${#} -ne 3 ]];
then
echo " " >&2
exit 2
fi


while read -r file;
do
res=$( grep -E -v -n "^(\{ .* \};|#.*)$" )
if [[ -n "${res}" ]];
then
echo "Error in $( basename ${file} ):"
echo "${res}"
else
cat "{file}" >> "${2}"
fi
done < <( find "${3}" -mindepth 1 -type f )

username=$( basename "${2}" | sed -E "s/(.*).log/\1/" )
if ! grep -E -q "username" "${1}";
then
passwd=$( pwgen 16 )
echo "${username}:${passwd}" >> "${1}"
echo "${username} ${passwd}"
fi

exit 0



~~~~~~~~~~~~~~Task: 2024IN02.sh~~~~~~~~~~~~~~

#!/bin//bash

if [[ ${#} -ne 2 ]];
then
echo "error"
exit 1
fi

classes=$( mktemp )

while read -r header;
do
decl=$( grep -E "^class [a-zA-Z_][a-zA-Z0-9_]* : ((private|protected|public) [a-zA-Z_][a-zA-Z0-9_]*,{,1}[ ]{,1})*$" "$header" )
className=$( echo "$decl" | cut -d ':' -f 1 | cut -d ' ' -f 2 )
echo "$className" >> "$classes"

doesDerives=$( echo "$decl" | grep -E -o ":" )
descs=""

if [[ "$doesDerives" == ":" ]];
then
descs=$( echo "$decl" | cut -d ':' -f 2 | tr ',' '\n' | cut -c 2- | sed -E "s/(private|protected|public) /${className}->/g" )
echo "$descs" >> "$classes"
fi
done < <( find "$1" -mindepth 1 -name "*.h" )

cat "$classes" >> "$2"
rm $classes
exit 0



~~~~~~~~~~~~~~Task: 2024SE06.sh~~~~~~~~~~~~~~

#!/bin/bash

if [[ ${#} -ne 1 ]];
then
echo "error" >&2
exit 2
fi

while read -r line;
do
filename=$( echo "${line}" | grep -E -o "^(/.*)+" )
filetype=$( echo "${line}" | grep -E -o "(dir|file|symlink|nonexistant)")
user=$( echo "${line}" | grep -E -o "\b.*:.*\b")
permMask=$( echo "${line}" | grep -E -o "[0-9]{,4}")

if [[ "${fileType}" == "symlink" ]];
then
dest=$( echo "$line" | cut -d ' ' -f 3 )
found=$( find "${filename}" )
if [[ -z "${found}" ]];
then
ln -s "${dest}" "${filename}"
continue
else
filetype=$( echo "${filetype}" | cut -c 1 )
fi

found=$( find "${filename}" )
if [[ -n "${found}" && "$filetype" == "nonexistant" ]];
then
rm -r "$filename"
fi

if [[ -z "$found" ]];
then
if [[ "${filetype}" == "nonexistant" ]];
then
continue
else
if [[ "${filetype}" == "d" ]];
then
mkdir "$filename"
chmod "$permMask" "$filename"
else
touch "$filename"
chmod "$permMask" "$filename"
fi
fi
else
if [[ "${filetype}" == "$(stat "$filename" -c "%F" )" ]];
then
chmod "$permMask" "$filename"
elif
rm -r "${found}"
if [[ "${filetype}" == "d" ]];
then
mkdir "$filename"
chmod "$permMask" "$filename"
else
touch "$filename"
chmod "$permMask" "$filename"
fi
fi
fi
if [[ -n "$user" ]];
then
chown "$user" "$filename"
fi
done < "${1}"

exit 0



~~~~~~~~~~~~~~Task: 2024SE01.sh~~~~~~~~~~~~~~

#!/bin/bash

if [[ ${#} -eq 0 ]];
then
echo "error"
exit 3
fi

file="wh"
dict=$( mktemp )
for arg in "${@}";
do
if [[ "${arg}" =~ -R.*=.* ]];
then
words=$( echo "${arg}" | cut -c 3- )
echo "${words}" >> "${dict}"
else
file=$(find . -name "${arg}")
fi
done

codedWords=$( mktemp )
while read -r pair;
do
toCode=$( echo "${pair}" | cut -d '=' -f 1 )
coded=$( pwgen )
echo "${toCode}=${coded}" >> "${codedWords}"
done < "${dict}"

while read -r code;
do
from=$( echo "${code}" | cut -d '=' -f 1 )
to=$( echo "${code}" | cut -d '=' -f 2 )
sed -E -i "s/\b${from}\b/${to}/g" "${file}"
done < "${codedWords}"

while read -r pair;
do
search=$( echo "${pair}" | cut -d '=' -f 1 )
from=$( echo "${pair}" | cut -d '=' -f 2)
to=$( grep -E "^${search}" "${dict}" | cut -d '=' -f 2 )
sed -E -i "s/\b${from}\b/${to}/g" "${file}"
done < "${codedWords}"


rm ${dict} ${codedWords}
exit 0



~~~~~~~~~~~~~~Task: 2024SE04.sh~~~~~~~~~~~~~~

#!/bin/bash

if [[ ${#} -ne 1 ]];
then
echo "error" >&2
exit 2
fi

if [[ -f "${1}" ]];
then
exit 2
fi

while read -r line;
do
canBeBuild=1
dependants=$( echo "${line}" | cut -d ':' -f 2 )
while read -r file;
do
if ! find . -mindepth 1 -name "${file}" | grep -q .;
then
if grep -E "^${file}" "${1}";
then
if ! ./2024SE04.sh "${file}";
then
canBeBuild=0
break
fi
else
canBeBuild=0
break
fi
else
continue
fi

if [[ canBeBuild -eq 0 ]];
then
echo "Error, ${file} can't be build"
fi

commandName=$( echo "${line}" | cut -d ':' -f 3- )
name=$( echo "${line}" | cut -d ':' -f 1 )
eval "${commandName} ${name}"
done< <( echo "${dependants}" )
done < "${1}"

exit 0



~~~~~~~~~~~~~~Task: 2024SE02.sh~~~~~~~~~~~~~~

#!/bin/bash

if [[${#} -ne 0 ]];
then
echo "error"
exit 1
fi

SCRIPT_DIR=$( dirname $0 )
users=$( cut -d: -f 1,3 | grep -E "^.*:1[0-9]{3,}$" /etc/passwd | cut -d: -f 1 | sort )
prevCloudUsers=$("$SCRIPT_DIR"/occ user:list | tail -n +2 | cut -d: -f 1 | cut -d ' ' -f 2 | sort )

localsNotInPC=$( comm <(echo "$users") <(echo "$prevCloudUsers") -2 -3 )
PCNotInLocal=$( comm <(echo "$users") <(echo "$prevCloudUsers") -1 -3  )
mutual=$( comm <(echo "$users") <(echo "$prevCloudUsers") -1 -2 )
while read -r user;
do
"$SCRIPT_DIR"/occ user:add "${user}"
done < <( echo "${localIsNotInPC}" )

while read -r user;
do
info=$( "$SCRIPT_DIR"/occ user:info ${user} | grep -E "^enabled:" | cut -d: -f 2 | tr -s ' ' )
if [[ "${info}" == "true" ]];
then
continue
else
"${SCRIPT_DIR}"/occ user:enable "$user"
fi
done < <( echo "${mutual}" )

while read -r user;
do
"$SCRIPT_DIR"/occ suer:disable "${user}"
done < <( echo "${PCNotInLocal}" )


rm "${prevCloudUsers}"
exit 0



~~~~~~~~~~~~~~Task: 2024SE05.sh~~~~~~~~~~~~~~

#!/bin/bash

if [[ ${#} -ne 2 ]];
then
echo "error"
exit 3
fi

#File is in format: hour(hh:mm) day date(dd/mm/yyyy);value
value=$( eval "${1}")
hour=$( date +"%H" )
day=$( date +"%a" )
avg=$( grep "E" "^${hour}:[0-9]{2} ${day} [0-9]{2}/[0-9]{2}/[0-9]{4};[0-9]+\.[0-9]+$" | awk -F ';' ' BEGIN { sum = 0; count = 0; } { sum += $2; count += 1; } END { print sum / count } ' )

if [[ $( echo "2 * ${avg} < ${value}" | bc -l ) -eq 1 ]] || [[ echo "${value} < ${avg} / 2" -eq 1 ]]
then
echo "$( date +"%x %R" | tr '/' '-' ): ${value} abnormal"
fi

exit 2



~~~~~~~~~~~~~~Task: 2021SE02.sh~~~~~~~~~~~~~~

#!/bin/bash

if [[ ${#} -eq 0 ]];
then
echo "error"
exit 1
fi

for file in "${@}";
do
firstLine=$( head -n 1 "${file}" )

if ! echo "${firstLine}" | grep -Eoq "\bSOA\b";
then
echo "First line must be SOA record..."
continue
fi

SOArecs=$( grep -Eo "SOA" "${file}" | wc -l )
if [[ ${SOArecs} -gt 1 ]];
then
echo "In a file only 1 SOA record is allowed..."
continue
fi

if [[ "${firstLine}" =~ ^([a-z0-9]+.)+.*\($ ]];
then
serial=$( cat "${file}" | head -n 2 | tail -n 1 | tr -d [[:space:]] | cut -d ';' -f 1 )
fileDate=$( echo "${serial}" | cut -c 1-8 )
currDate=$( date +"%F" | tr -d '-' )

if [[ "${currDate}" == "${fileDate}" ]];
then
currC=$( echo "$serial" | cut -c 9-)
added="$( echo "${currC} + 1" | bc -l )"
if [[ $added =~ [0-9]{1} ]];
then
added=$( echo "0$added" )
fi
newSerial=$( date +"%F${added}" | tr -d '-' )

sed -E -i "s/${serial}/${newSerial}/" "${file}"
else
newSerial=$( date +"%F00" | tr -d '-' )
sed -E -i "s/${serial}/${newSerial}/" "${file}"
fi
else
serial=$( echo "${firstLine}" | tr -s ' ' | cut -d ' ' -f 7 )
fileDate=$( echo "${serial}" | cut -c 1-8 )
currDate=$( date +"%F" | tr -d '-' )

if [[ "${currDate}" == "${fileDate}" ]];
then
currC=$( echo "$serial" | cut -c 9-)
added="$( echo "${currC} + 1" | bc -l )"
if [[ $added =~ [0-9]{1} ]];
then
added=$( echo "0$added" )
fi
newSerial=$( date +"%F${added}" | tr -d '-' )

sed -E -i "s/${serial}/${newSerial}/" "${file}"
else
newSerial=$( date +"%F00" | tr -d '-' )
sed -E -i "s/${serial}/${newSerial}/" "${file}"
fi
fi
done

exit 0



~~~~~~~~~~~~~~Task: 2016SE03.sh~~~~~~~~~~~~~~

#!/bin/bash

if [[ ${#} -ne 0 ]];
then
echo "Script doesn't need arguments..."
exit 2
fi

if [[ "$(whoami)" != "root" ]];
then
echo "Script can be used only by root..."
exit 2
fi

grep -E "^.+nologin$" /etc/passwd
notWrit=$( cut -d: -f6 /etc/passwd | xargs  stat -c "%A %n" 2>/dev/null | grep -E "^.{2}[^w].+$" | cut -d ' ' -f2 )

for file in "${notWrit}";
do
grep -E "${file}" /etc/passwd
done



~~~~~~~~~~~~~~Task: 2016SE05.sh~~~~~~~~~~~~~~

#!/bin/bash

if [[ ${#} -ne 2 ]];
then
echo "Script takes 2 arguments..."
exit 2
fi

if [[ ! -e ${1} || -e ${2} ]];
then
echo "One of the files doesn't exist..."
exit 2
fi

f1Count=$(cat "${1}" | grep -E "${1}" | wc -l)
f2Count=$(cat "${2}" | grep -E "${2}" | wc -l)

if [[ ${f1Count} -gt ${f2Count} ]];
then
touch "${1}.songs"
cut -d ' ' -f 4- "${1}" | sort >"${1}.songs"
else
touch "${2}.songs"
cut -d ' ' -f 4- "${2}" | sort >"${2}.songs"
fi

exit 0



~~~~~~~~~~~~~~Task: 2016SE06.sh~~~~~~~~~~~~~~

#!/bin/bash

if [[ ${#} -ne 1 ]];
then
echo "File needs 1 argument..."
exit 2
fi

awk -F '„' ' { printf NR } {printf ". „"} { print $2 }' "${1}" | sort -t '.' -k 2



~~~~~~~~~~~~~~Task: 2016SE04.sh~~~~~~~~~~~~~~

#!/bin/bash

if [[ ${#} -ne 2 ]];
then
echo "Script need exactly 2 parameters..."
exit 2
fi

if [[ ! -d a || ! -d b || ! -d c ]]
then
mkdir -p ./a ./b ./c
fi

while read -r file;
do
rows=$( cat ${file} | wc -l )
if [[ ${rows} -lt ${1} ]];
then
mv ${file} ./a
elif [[ ${rows} -ge ${1} && ${rows} -le ${2} ]];
then
mv ${file} ./b
else
mv ${file} ./c
fi
done < <(find . -type f)

exit 0



~~~~~~~~~~~~~~Task: 2016SE02.sh~~~~~~~~~~~~~~

#!/bin/bash

if [[ $# -ne 1 ]];
then
echo "Script takes exactly 1 argument..."
exit 2
fi

if [[ ! "$1" =~ ^[0-9]+$ ]];
then
echo "Argument must be a number..."
exit 2
fi

if [[ "$(whoami)" != "root" ]];
then
echo "To use this script you must be root..."
exit 2
fi

while read -r user;
do
memUsed=$( ps -u "${user}" -o pid,rss --noheader | tr -s ' ' | awk -F ' ' 'BEGIN { sum = 0} { sum += $2 } END { print sum }')
echo "$memUsed"

if [[ $memUsed -gt $1 ]];
then
largestP=$( ps -u ${user} -o pid,rss | tr -s ' ' | sort -t ' ' -k 4 -n | head -n 1 | cut -d ' ' -f 1)
echo "kill: ${largestP}"
fi
done < <(who | cut -d ' ' -f 1)
exit 0



~~~~~~~~~~~~~~Task: 2016SE01.sh~~~~~~~~~~~~~~

#!/bin/bash

if [[ $# -ne 1 ]];
then
echo "Script takes one argument exactly..."
exit 2
fi

if [[ ! -d "$1" ]];
then
echo "Parameter must be a directory..."
exit 2
fi

echo "Symbolic links: "
find "$1" -mindepth 1 -maxdepth 1 -type l

echo "Sub-directories with non-existing destination: "
find "$1" -mindepth 1 -maxdepth 1 -type l ! -exec test -e {} \; -print



~~~~~~~~~~~~~~Task: 2018SE01.sh~~~~~~~~~~~~~~

#!/bin/bash

if [[ ${#} -ne 1 ]];
then
echo "Script needs 1 argument..." >&2
exit 2
fi

tempFile=$(mktemp)

while read -r friendDir;
do
currLines=$( find "${friendDir}" -type f -exec cat {} \; | wc -l )
currFriend=$( basename "${friendDir}" )
echo "${currFriend}:${currLines}" >> "${tempFile}"
done < <( find "${1}" -mindepth 3 -maxdepth 3 -type d )

cat "${tempFile}" | awk -F ':' ' { lines[$1] += $2 } END { for ( friend in lines ) { print friend, lines[friend] } } ' | sort -t ':' -k 2 -n -r | head -n 10



~~~~~~~~~~~~~~Task: 2018SE02.sh~~~~~~~~~~~~~~

#!/bin/bash

if [[ ${#} -ne 2 ]];
then
echo "Script needs 2 arguments..." >&2
exit 2
fi

if [[ -n "$( find "${1}" -mindepth 1 )" ]];
then
echo "Directory must be empty..." >&2
exit 2
fi

touch "${1}/dict.txt"
num=1

while read -r line;
do
name=$( echo "${line}" | cut -d ':' -f 1 | cut -d ' ' -f 1,2 )
if ! grep -E -q "${name}" "${1}/dict.txt";
then
echo "${name}:${num}" >> "${1}/dict.txt"
touch "${1}/${num}.txt"
num=$(( num + 1 ))
fi
done < <( cat "${2}" )

while read -r actorLine;
do
currName=$( echo "${actorLine}" | cut -d ':' -f 1 | cut -d ' ' -f 1,2 )
currNum=$( grep -E "${currName}" "${1}/dict.txt" | cut -d ':' -f 2)

echo "${actorLine}" >> "${1}/${currNum}.txt"
done < <( cat "${2}" )



~~~~~~~~~~~~~~Task: 2018SE03.sh~~~~~~~~~~~~~~

#!/bin/bash

if [[ ${#} -ne 2 ]];
then
echo "Script needs 2 arguments..." >&2
exit 2
fi

if [[ ! -f "${1}" || ! -f "${2}" ]];
then
echo "Files must be ordinary..." >&2
exit 2
fi


while read -r line;
do
id=$( echo "${line}" | cut -d ',' -f 1 )
text=$( echo "${line}" | cut -d ',' -f 2- )

match=$( grep -E "^[0-9]+,${text}$" "${2}" )
echo "id : ${id}, text: ${text}, match: ${match}"
if [[ -z "${match}" ]];
then
echo "${id},${text}" >> "${2}"
else
matchID=$( echo "${match}" | cut -d ',' -f 1)
if [[ ${matchID} -gt ${id} ]];
then
if [[ -z "$(grep -E "${id}")" ]];
then
sed -i "s/^${matchID},${text}$/${id},${text}/" "${2}"
else
continue
fi
else
continue
fi
fi
done < "${1}"

exit 0



~~~~~~~~~~~~~~Task: 2025IN02.sh~~~~~~~~~~~~~~

#!/bin/bash

if [[ ${#} -ne 2 ]];
then
echo "error" >&2
exit 2
fi

teams=$( cat "${2}" | tr -s ' ' | cut -d ' ' -f 3 | sort | uniq)

while read -r team;
do
currTeamServers=$( grep -E "^.*${team}$" "${2}" | tr -s ' ' | cut -d ' ' -f 1 )
currTeamZones=$( grep -E "^.*${team}$" "${2}" | tr -s ' ' | cut -d ' ' -f 2)

echo "; team ${team}"
while read -r zone;
do
while read -r server;
do
echo "${zone} IN NS ${server}.${1}."
done < <( echo "${currTeamServers}")
done < <( echo "${currTeamZones}" )
done < <(echo "${teams}")

exit 0



~~~~~~~~~~~~~~Task: 2025IN01.sh~~~~~~~~~~~~~~

#!/bin/bash

if [[ ${#} -ne 1 ]];
then
echo "err" >&2
exit 2
fi


while read -r line;
do
dir=$( echo "${line}" | tr -s ' ' | cut -d ' ' -f 1 )
ruleType=$( echo "${line}" | tr -s ' ' | cut -d ' ' -f 2 )
mask=$( echo "${line}" | tr -s ' ' | cut -d ' ' -f 3 )
while read -r file;
do
perms=$( stat "${file}" -c "%a" )

if [[ "${ruleType}" == "R" ]];
if [[ "${perms}" -eq "${mask}" ]];
then
if [[ -d "${file}" ]];
then
chmod 755 "${file}"
elif [[ -f "${file}" ]];
then
chmod 775 "${file}"
fi
fi
then
elif [[ "${ruleType}" == "A" ]];
if [[ $(( ${mask} & ${perms} -ne 0 ]];
then
if [[ -d "${file}" ]];
then
chmod 755 "${file}"
elif [[ -f "${file}" ]];
then
chmod 775 "${file}"
fi
fi
then
if [[ $(( ${perms} & ${mask} )) -eq ${mask} ]];
then
if [[ -d "${file}" ]];
then
chmod 755 "${file}"
elif [[ -f "${file}" ]];
then
chmod 775 "${file}"
fi
fi
else
fi
done < <( find "${dir}" -mindepth 1 -type \( d -o f \) )
done < "${1}"

exit 0
